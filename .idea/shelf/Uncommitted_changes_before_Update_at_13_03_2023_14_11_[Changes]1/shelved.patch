Index: conversionHexToAssembly.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nimport math\r\nimport os\r\nimport sys\r\nfrom time import sleep\r\nfrom PyQt5 import QtCore\r\nfrom PyQt5.QtCore import pyqtSignal\r\n\r\nCurrentInstruction = 0\r\nTotalInstructions = 1\r\n\r\n\r\n# Fonction pour récupérer le path des fichiers\r\ndef resource_path(relative_path):\r\n    try:\r\n        base_path = sys._MEIPASS2\r\n    except Exception:\r\n        base_path = os.path.abspath(\".\")\r\n\r\n    return os.path.join(base_path, relative_path)\r\n\r\n\r\n# Thread qui met à jour la valeur de la barre de progression\r\nclass ProgressThread(QtCore.QThread):\r\n    progress_signal = pyqtSignal(int)\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n    def run(self):\r\n        while 1:\r\n            self.progress_signal.emit(int(CurrentInstruction / TotalInstructions * 100))\r\n            sleep(0.1)\r\n\r\n\r\n# Fonction qui lit le fichier d'entrée et écrit chaque instruction en binaire\r\ndef writeBinaryInstructions(filepath, simpleInstruction=False):\r\n    if simpleInstruction:\r\n        STMFile = open(filepath)\r\n        STMFileLine = STMFile.readline()\r\n        data_binary = \"\"\r\n        for c in STMFileLine:\r\n            data_binary += str(bin(int(c, 16))[2:].zfill(4))\r\n        data_big_endian = \"\"\r\n        for i in range(0, len(data_binary), 8):\r\n            data_big_endian = data_big_endian + data_binary[i:i + 8]\r\n        data_reformatted = \"\"\r\n        i = 0\r\n        if len(data_big_endian) < 32:\r\n            tmp = data_big_endian[i:i + 32]\r\n            data_reformatted += tmp[24:] + tmp[16:24] + tmp[8:16] + tmp[:8]\r\n            i += 32\r\n        instructions_file = open(resource_path(\"ConversionFiles\\\\instructions_file.txt\"), \"w\")\r\n        if len(data_reformatted) < 32:\r\n            instructions_file.write(data_reformatted)\r\n            instructions_file.close()\r\n    else:\r\n        global TotalInstructions\r\n        global CurrentInstruction\r\n        CurrentInstruction = 0\r\n        TotalInstructions = 1\r\n        STMfile = open(filepath)\r\n        STMfileLines = STMfile.readlines()\r\n        data_STMfile = \"\"\r\n        addresses = []\r\n        for STMfileLine in STMfileLines:\r\n            data_STMfile += STMfileLine[12:-3]\r\n            addresses.append(STMfileLine[4:12])\r\n        data_binary = \"\"\r\n        # Boucle qui convertit l'hexadécimal au binaire\r\n        for c in data_STMfile:\r\n            data_binary += str(bin(int(c, 16))[2:].zfill(4))\r\n        data_big_endian = \"\"\r\n        # Boucle qui convertit les données de Little Endian en Big Endian\r\n        for i in range(0, len(data_binary) - 15, 8):\r\n            data_big_endian = data_big_endian + data_binary[i:i + 8]\r\n        i = 0\r\n        data_reformatted = \"\"\r\n        # Boucle qui reformatte les données par groupe de 32 bits\r\n        while i < len(data_big_endian) - 31:\r\n            tmp = data_big_endian[i:i + 32]\r\n            data_reformatted += tmp[24:] + tmp[16:24] + tmp[8:16] + tmp[:8]\r\n            i += 32\r\n        instructions_file = open(resource_path(\"ConversionFiles\\\\instructions_file.txt\"), \"w\")\r\n        i = 0\r\n        if len(data_reformatted) < 32:\r\n            instructions_file.write(addresses[0] + data_reformatted)\r\n            instructions_file.close()\r\n            return\r\n        # Boucle qui écrit le fichier de sortie avec chaque instruction\r\n        while i < len(data_reformatted) - 31:\r\n            tmp = data_reformatted[i:i + 32]\r\n            if tmp[0:3] == \"111\" and tmp[3:5] != \"00\":\r\n                instructions_file.write(addresses[math.floor(i / 256)] + tmp + '\\n')\r\n                i += 32\r\n            else:\r\n                instructions_file.write(addresses[min(round(i / 256), len(addresses) - 1)] + tmp[:16] + '\\n')\r\n                i += 16\r\n\r\n\r\n# Fonction qui détermine si une instruction est 16 bits ou 32 bits\r\ndef is32bits(instruction):\r\n    if instruction[0:3] == '111' and instruction[3:5] != \"00\":\r\n        return True\r\n    else:\r\n        return False\r\n\r\n\r\n# Fonction qui lit le JSON et retourne les arguments d'une instruction avec leurs valeurs\r\ndef GetDictField_16(json_file, line, index):\r\n    finalString = \"\"\r\n    try:\r\n        fields = json_file[str(line[:index])]['fields']\r\n    except:\r\n        return \"\"\r\n    keys = fields.keys()\r\n    newBit = dict()\r\n    for i in range(len(fields)):\r\n        tmp = fields[list(keys)[i]]\r\n        var1 = 15 - int(tmp[0])\r\n        var2 = 15 - int(tmp[1])\r\n        if var1 > var2:\r\n            newTab = [var1, var2]\r\n        else:\r\n            newTab = [var2, var1]\r\n        newBit[list(fields.keys())[i]] = newTab\r\n    newDict = dict()\r\n    for i in range(len(newBit)):\r\n        tmp = newBit[list(keys)[i]]\r\n        newDict[list(newBit.keys())[i]] = int(line[tmp[1]:tmp[0] + 1], 2)\r\n    for j in range(len(newDict) - 1):\r\n        key = list(keys)[j]\r\n        if key[0] == 'R':\r\n            match key[1]:\r\n                case \"n\":\r\n                    finalString += 'Rn' + str(newDict[list(keys)[j]]) + ', '\r\n                case \"m\":\r\n                    finalString += 'Rm' + str(newDict[list(keys)[j]]) + ', '\r\n                case \"d\":\r\n                    finalString += 'Rd' + str(newDict[list(keys)[j]]) + ', '\r\n                case \"t\":\r\n                    finalString += 'Rt' + str(newDict[list(keys)[j]]) + ', '\r\n        if key[:3] == 'imm':\r\n            finalString += '#' + str(newDict[list(keys)[j]]) + ', '\r\n    key = list(keys)[-1]\r\n    if key[0] == 'R':\r\n        match key[1]:\r\n            case \"n\":\r\n                finalString += 'Rn' + str(newDict[list(keys)[-1]])\r\n            case \"m\":\r\n                finalString += 'Rm' + str(newDict[list(keys)[-1]])\r\n            case \"d\":\r\n                finalString += 'Rd' + str(newDict[list(keys)[-1]])\r\n            case \"t\":\r\n                finalString += 'Rt' + str(newDict[list(keys)[-1]])\r\n    if key[:3] == 'imm':\r\n        finalString += '#' + str(newDict[list(keys)[-1]])\r\n    return finalString\r\n\r\n\r\n# Fonction qui écrit les instructions détaillées dans un fichier de sortie\r\ndef write_described_instruction_16(descr_file, json_file, line, index, code, address):\r\n    match code:\r\n        case \"Compact\":\r\n            descr_file.write(\"0x\" + str(hex(int(address, 16)))[2:].zfill(8) + \" : \" + json_file[str(line[:index])][\r\n                'instruction'] + ' : ' + GetDictField_16(json_file, line, index) + \"\\n\")\r\n        case \"Classique\":\r\n            descr_file.write(\"0x\" + str(hex(int(address, 16)))[2:].zfill(8) + \" : \" + json_file[str(line[:index])][\r\n                'meaning'] + ' : ' + GetDictField_16(json_file, line, index) + \"\\n\")\r\n        case \"Classic\":\r\n            descr_file.write(\"0x\" + str(hex(int(address, 16)))[2:].zfill(8) + \" : \" + json_file[str(line[:index])][\r\n                'meaning'] + ' : ' + GetDictField_16(json_file, line, index) + \"\\n\")\r\n        case \"Integral\":\r\n            descr_file.write(\r\n                \"0x\" + str(hex(int(address, 16)))[2:].zfill(8) + \" : \" + line + ' : ' + json_file[str(line[:index])]['meaning'] + \" : \" + GetDictField_16(json_file, line, index) + \"\\n\")\r\n\r\n\r\n# Fonction qui lit le JSON et retourne les arguments d'une instruction avec leurs valeurs\r\ndef GetDictField_32(json_file, line, instruction):\r\n    finalString = \"\"\r\n    fields = json_file[str(instruction)]['fields']\r\n    keys = fields.keys()\r\n    newBit = dict()\r\n    for i in range(len(fields)):\r\n        tmp = fields[list(keys)[i]]\r\n        var1 = 31 - int(tmp[0])\r\n        var2 = 31 - int(tmp[1])\r\n        if var1 > var2:\r\n            newTab = [var1, var2]\r\n        else:\r\n            newTab = [var2, var1]\r\n        newBit[list(fields.keys())[i]] = newTab\r\n    newDict = dict()\r\n    for i in range(len(newBit)):\r\n        tmp = newBit[list(keys)[i]]\r\n        newDict[list(newBit.keys())[i]] = int(line[tmp[1]:tmp[0] + 1], 2)\r\n    for j in (range(len(newDict) - 1, 0, -1)):\r\n        key = list(keys)[j]\r\n        match key[0]:\r\n            case 'R':\r\n                match key[1]:\r\n                    case \"n\":\r\n                        finalString += 'Rn' + str(newDict[list(keys)[j]]) + ', '\r\n                    case \"m\":\r\n                        finalString += 'Rm' + str(newDict[list(keys)[j]]) + ', '\r\n                    case \"d\":\r\n                        finalString += 'Rd' + str(newDict[list(keys)[j]]) + ', '\r\n                    case \"t\":\r\n                        finalString += 'Rt' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'W':\r\n                finalString += 'W' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'T':\r\n                finalString += 'T' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'U':\r\n                finalString += 'U' + str(newDict[list(keys)[j]]) + ', '\r\n        match key[:2]:\r\n            case 'tb':\r\n                finalString += 'tb' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'sh':\r\n                finalString += 'tb' + str(newDict[list(keys)[j]]) + ', '\r\n        match key[:3]:\r\n            case 'imm':\r\n                finalString += '#' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'Rt2':\r\n                finalString += 'Rt2 ' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'CRd':\r\n                finalString += 'CRd' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'CRm':\r\n                finalString += 'CRm ' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'CRn':\r\n                finalString += 'CRm ' + str(newDict[list(keys)[j]]) + ', '\r\n        match key[:4]:\r\n            case 'type':\r\n                finalString += 'type:' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'SYSm':\r\n                finalString += 'SYSm:' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'mask':\r\n                finalString += 'mask:' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'cond':\r\n                finalString += 'cond:' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'RdLo':\r\n                finalString += 'RdLo:' + str(newDict[list(keys)[j]])\r\n            case 'RdHi':\r\n                finalString += 'RdHi:' + str(newDict[list(keys)[j]])\r\n            case 'opc1':\r\n                finalString += 'opc1:' + str(newDict[list(keys)[j]])\r\n            case 'opc2':\r\n                finalString += 'opc2:' + str(newDict[list(keys)[j]])\r\n        match key[:6]:\r\n            case 'option':\r\n                finalString += 'option:' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'rotate':\r\n                finalString += 'rotate:' + str(newDict[list(keys)[j]]) + ', '\r\n            case 'coproc':\r\n                finalString += 'coproc:' + str(newDict[list(keys)[j]]) + ', '\r\n        if key[:5] == 'shift':\r\n            finalString += 'shift:' + str(newDict[list(keys)[j]]) + ', '\r\n        elif key[:7] == 'sat_imm':\r\n            finalString += 'sat_imm:' + str(newDict[list(keys)[j]]) + ', '\r\n        elif key[:7] == 'widthm1':\r\n            finalString += 'widthm1:' + str(newDict[list(keys)[j]]) + ', '\r\n        elif key[:13] == 'register_list':\r\n            finalString += 'register_list:' + str(newDict[list(keys)[j]]) + ', '\r\n    key = list(keys)[-1]\r\n    match key[0]:\r\n        case 'R':\r\n            match key[1]:\r\n                case \"n\":\r\n                    finalString += 'Rn' + str(newDict[list(keys)[-1]]) + ', '\r\n                case \"m\":\r\n                    finalString += 'Rm' + str(newDict[list(keys)[-1]]) + ', '\r\n                case \"d\":\r\n                    finalString += 'Rd' + str(newDict[list(keys)[-1]]) + ', '\r\n                case \"t\":\r\n                    finalString += 'Rt' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'W':\r\n            finalString += 'W' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'T':\r\n            finalString += 'T' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'U':\r\n            finalString += 'U' + str(newDict[list(keys)[-1]]) + ', '\r\n    match key[:2]:\r\n        case 'tb':\r\n            finalString += 'tb' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'sh':\r\n            finalString += 'tb' + str(newDict[list(keys)[-1]]) + ', '\r\n    match key[:3]:\r\n        case 'imm':\r\n            finalString += '#' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'Rt2':\r\n            finalString += 'Rt2 ' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'CRd':\r\n            finalString += 'CRd' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'CRm':\r\n            finalString += 'CRm ' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'CRn':\r\n            finalString += 'CRm ' + str(newDict[list(keys)[-1]]) + ', '\r\n    match key[:4]:\r\n        case 'type':\r\n            finalString += 'type:' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'SYSm':\r\n            finalString += 'SYSm:' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'mask':\r\n            finalString += 'mask:' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'cond':\r\n            finalString += 'cond:' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'RdLo':\r\n            finalString += 'RdLo:' + str(newDict[list(keys)[-1]])\r\n        case 'RdHi':\r\n            finalString += 'RdHi:' + str(newDict[list(keys)[-1]])\r\n        case 'opc1':\r\n            finalString += 'opc1:' + str(newDict[list(keys)[-1]])\r\n        case 'opc2':\r\n            finalString += 'opc2:' + str(newDict[list(keys)[-1]])\r\n    match key[:6]:\r\n        case 'option':\r\n            finalString += 'option:' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'rotate':\r\n            finalString += 'rotate:' + str(newDict[list(keys)[-1]]) + ', '\r\n        case 'coproc':\r\n            finalString += 'coproc:' + str(newDict[list(keys)[-1]]) + ', '\r\n    if key[:5] == 'shift':\r\n        finalString += 'shift:' + str(newDict[list(keys)[-1]]) + ', '\r\n    elif key[:7] == 'sat_imm':\r\n        finalString += 'sat_imm:' + str(newDict[list(keys)[-1]]) + ', '\r\n    elif key[:7] == 'widthm1':\r\n        finalString += 'widthm1:' + str(newDict[list(keys)[-1]]) + ', '\r\n    elif key[:13] == 'register_list':\r\n        finalString += 'register_list:' + str(newDict[list(keys)[-1]]) + ', '\r\n    return finalString\r\n\r\n\r\n# Fonction qui écrit les instructions détaillées dans un fichier de sortie\r\ndef write_described_instruction_32(descr_file, json_file, line, instruction, code, address):\r\n    match code:\r\n        case \"Compact\":\r\n            descr_file.write(\"0x\" + str(hex(int(address, 16)))[2:].zfill(8) + \" : \" + json_file[str(instruction)]['instruction'] + ' : ' + GetDictField_32(json_file, line, instruction) + \"\\n\")\r\n        case \"Classique\":\r\n            descr_file.write(\"0x\" + str(hex(int(address, 16)))[2:].zfill(8) + \" : \" + json_file[str(instruction)]['meaning'] + ' : ' + GetDictField_32(json_file, line, instruction) + \"\\n\")\r\n        case \"Classic\":\r\n            descr_file.write(\"0x\" + str(hex(int(address, 16)))[2:].zfill(8) + \" : \" + json_file[str(instruction)]['meaning'] + ' : ' + GetDictField_32(json_file, line, instruction) + \"\\n\")\r\n        case \"Integral\":\r\n            descr_file.write(\"0x\" + str(hex(int(address, 16)))[2:].zfill(8) + \" : \" + line[:-1] + ' : ' + json_file[str(instruction)]['meaning'] + \" : \" + GetDictField_32(json_file, line, instruction) + \"\\n\")\r\n\r\n\r\n# Fonction qui lit les bits et lance l'écriture des instructions.\r\n# Elle contient aussi l'arbre de décision\r\ndef describe_instructions(code, simpleInstruction=False):\r\n    global TotalInstructions\r\n    global CurrentInstruction\r\n    file = open(resource_path(\"ConversionFiles\\\\instructions_file.txt\"), \"r\")\r\n    assembly_description = open(resource_path(\"ConversionFiles\\\\Assembly.txt\"), \"w\")\r\n    lines = file.readlines()\r\n    TotalInstructions = len(lines)\r\n    json_16 = json.load(open(resource_path(\"ConversionFiles\\\\Json_Decoding_ARM_16bit.json\"), \"r\"))\r\n    json_32 = json.load(open(resource_path(\"ConversionFiles\\\\Json_Decoding_ARM_32bit.json\"), \"r\"))\r\n    for binary_line in lines:\r\n        if simpleInstruction:\r\n            address = \"00000000\"\r\n            line = binary_line\r\n        else:\r\n            address = binary_line[:8]\r\n            line = binary_line[8:-1]\r\n        CurrentInstruction += 1\r\n        if is32bits(line):\r\n            if line == \"11111111111111111111111111111111\":\r\n                assembly_description.write(\"0x\" + str(hex(int(address, 16)))[2:].zfill(8) + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n            else:\r\n                # Load/Store\r\n                if line[:7] == \"1110100\":\r\n                    # Load/Store Multiple\r\n                    if line[7:9] == \"01\" and line[11] == \"0\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"1110100010x0\", code, address)\r\n                    elif line[7:9] == \"01\" and line[11] == \"1\" and line[10] != \"0\" and line[12:16] != \"1101\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"1110100010x1\", code, address)\r\n                    elif line[7:9] == \"01\" and line[11] == \"1\" and line[10] == \"0\" and line[12:16] == \"1101\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"1110100010111101\", code, address)\r\n                    elif line[7:9] == \"10\" and line[11] == \"0\" and line[10] != \"0\" and line[12:16] != \"1101\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"1110100100x0\", code, address)\r\n                    elif line[7:9] == \"10\" and line[11] == \"0\" and line[10] == \"0\" and line[12:16] == \"1101\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"1110100100101101\", code, address)\r\n                    elif line[7:9] == \"10\" and line[11] == \"1\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"1110100100x1\", code, address)\r\n                    # Load/Store dual or exclusive, table branch\r\n                    elif line[7:9] == \"00\" and line[10:12] == \"00\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111010000100\", code, address)\r\n                    elif line[7:9] == \"00\" and line[10:12] == \"01\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111010000101\", code, address)\r\n                    elif (line[7] == \"0\" and line[10:12] == \"10\") or (line[7] == \"1\" and line[11] == \"0\"):\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111010000110\", code, address)\r\n                    elif (line[7] == \"0\" and line[10:12] == \"11\" and line[12:16] != \"1111\") or (line[7] == \"1\" and line[11] == \"1\" and line[12:16] != \"1111\"):\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111010000111\", code, address)\r\n                    elif (line[7] == \"0\" and line[10:12] == \"11\" and line[12:16] == \"1111\") or (line[7] == \"1\" and line[11] == \"1\" and line[12:16] == \"1111\"):\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"1110100xx1x11111\", code, address)\r\n                    elif line[7:9] == \"01\":\r\n                        if line[10:12] == \"00\" and line[24:28] == \"0100\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111010001100xxxxxxxx11110100\", code, address)\r\n                        elif line[10:12] == \"00\" and line[24:28] == \"0101\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111010001100xxxxxxxx11110101\", code, address)\r\n                        elif line[10:12] == \"01\":\r\n                            match line[24:28]:\r\n                                case \"0000\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111010001101xxxx111100000000\", code, address)\r\n                                case \"0001\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111010001101xxxx111100000001\", code, address)\r\n                                case \"0100\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111010001101xxxxxxxx111101001111\", code, address)\r\n                                case \"0101\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111010001101xxxxxxxx111101011111\", code, address)\r\n                                case _:\r\n                                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                        else:\r\n                            assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # Data processing (shifted register)\r\n                elif line[:7] == \"1110101\":\r\n                    match line[7:11]:\r\n                        case \"0000\":\r\n                            if line[20:24] != \"1111\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11101010000\", code, address)\r\n                            elif line[20:24] == \"1111\" and line[11] == \"1\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111010100001xxxxxxxx1111\", code, address)\r\n                            else:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                        case \"0001\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11101010001\", code, address)\r\n                        case \"0010\":\r\n                            if line[12:16] != \"1111\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11101010010\", code, address)\r\n                            else:\r\n                                if line[26:28] == \"00\" and line[17:20] == \"000\" and line[24:26] == \"00\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11101010010x1111x000xxxx0000\", code, address)\r\n                                elif line[26:28] == \"00\" and line[17:20] != \"000\" and line[24:26] != \"00\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11101010010x1111xxxxxxxxxx00\", code, address)\r\n                                elif line[26:28] == \"01\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11101010010x1111xxxxxxxxxx01\", code, address)\r\n                                elif line[26:28] == \"10\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11101010010x1111xxxxxxxxxx10\", code, address)\r\n                                elif line[26:28] == \"11\":\r\n                                    if line[17:20] == \"000\" and line[24:26] == \"00\":\r\n                                        write_described_instruction_32(assembly_description, json_32, line, \"11101010010x1111x000xxxx0011\", code, address)\r\n                                    else:\r\n                                        write_described_instruction_32(assembly_description, json_32, line, \"11101010010x1111xxxxxxxxxx11\", code, address)\r\n                                else:\r\n                                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                        case \"0011\":\r\n                            if line[12:16] != \"1111\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11101010011\", code, address)\r\n                            else:\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11101010011x1111\", code, address)\r\n                        case \"0100\":\r\n                            if line[20:24] != \"1111\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11101010100\", code, address)\r\n                            elif line[20:24] == \"1111\" and line[11] == \"1\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111010101001xxxxxxxx1111\", code, address)\r\n                            else:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                        case \"0110\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11101010110\", code, address)\r\n                        case \"1000\":\r\n                            if line[20:24] != \"1111\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11101011000\", code, address)\r\n                            elif line[20:24] == \"1111\" and line[11] == \"1\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111010110001xxxxxxxx1111\", code, address)\r\n                            else:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                        case \"1010\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11101011010\", code, address)\r\n                        case \"1011\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11101011011\", code, address)\r\n                        case \"1101\":\r\n                            if line[20:24] != \"1111\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11101011101\", code, address)\r\n                            elif line[20:24] == \"1111\" and line[11] == \"1\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111010111011xxxxxxxx1111\", code, address)\r\n                            else:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                        case \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11101011110\", code, address)\r\n                        case _:\r\n                            assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # Data processing (modified immediate)\r\n                elif line[:5] == \"11110\" and line[16] == \"0\":\r\n                    if line[6] == \"0\":\r\n                        match line[7:11]:\r\n                            case \"0000\":\r\n                                if line[20:24] != \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x00000\", code, address)\r\n                                else:\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x00000xxxxxxxxx1111\", code, address)\r\n                            case \"0001\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11110x00001\", code, address)\r\n                            case \"0010\":\r\n                                if line[12:16] != \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x00010\", code, address)\r\n                                else:\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x00010x1111\", code, address)\r\n                            case \"0011\":\r\n                                if line[12:16] != \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x00011\", code, address)\r\n                                else:\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x00011x1111\", code, address)\r\n                            case \"0100\":\r\n                                if line[20:24] != \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x00100\", code, address)\r\n                                else:\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x00100xxxxxxxxx1111\", code, address)\r\n                            case \"1000\":\r\n                                if line[20:24] != \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x01000\", code, address)\r\n                                else:\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x01000xxxxxxxxx1111\", code, address)\r\n                            case \"1010\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11110x01010\", code, address)\r\n                            case \"1011\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11110x01011\", code, address)\r\n                            case \"1101\":\r\n                                if line[20:24] != \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x01101\", code, address)\r\n                                else:\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x01101xxxxxxxxx1111\", code, address)\r\n                            case \"1110\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11110x01110\", code, address)\r\n                            case _:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                    # Data processing (plain binary immediate)\r\n                    else:\r\n                        match line[7:12]:\r\n                            case \"00000\":\r\n                                if line[12:16] != \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x10000011110\", code, address)\r\n                                else:\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x100000xxxx0\", code, address)\r\n                            case \"00100\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11110x100100xxxx0\", code, address)\r\n                            case \"01010\":\r\n                                if line[12:16] != \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x101010xxxx0\", code, address)\r\n                                else:\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110x1010101111\", code, address)\r\n                            case \"01100\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11110x101100xxxx0\", code, address)\r\n                            case \"10000\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"1111001100x0xxxx0xxxxxxxxx0\", code, address)\r\n                            case \"10010\":\r\n                                if line[17:20] != \"000\" and line[24:26] != \"00\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"1111001100x0xxxx0xxxxxxxxx0\", code, address)\r\n                                else:\r\n                                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                            case \"10100\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111100110100xxxx0xxxxxxxxx0\", code, address)\r\n                            case \"10110\":\r\n                                if line[12:16] != \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111100110110xxxx0xxxxxxxxx0\", code, address)\r\n                                else:\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"11110011011011110xxxxxxxxx0\", code, address)\r\n                            case \"11000\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"1111001110x0xxxx0xxxxxxxxx0\", code, address)\r\n                            case \"11010\":\r\n                                if line[17:20] != \"000\" and line[24:26] != \"00\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"1111001110x0xxxx0xxxxxxxxx0\", code, address)\r\n                                else:\r\n                                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                            case \"11100\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111100111100xxxx0xxxxxxxxx0\", code, address)\r\n                            case _:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # Branches and miscellaneous control\r\n                elif line[:5] == \"11110\" and line[16] == \"1\":\r\n                    if line[17:20] in [\"000\", \"010\"]:\r\n                        if line[6:10] != \"111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11110xxxxxxxxxxx10x0\", code, address)\r\n                        elif line[5:12] == \"011100\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11110011100\", code, address)\r\n                        elif line[5:12] == \"011111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11110011111\", code, address)\r\n                        elif line[5:12] == \"0111010\":\r\n                            if line[21:24] == \"000\":\r\n                                if line[24:28] == \"1111\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111100111010xxxx10x1x0001111\", code, address)\r\n                                match line[24:]:\r\n                                    case \"00000000\":\r\n                                        write_described_instruction_32(assembly_description, json_32, line, \"111100111010xxxx10x0x00000000000\", code, address)\r\n                                    case \"00000001\":\r\n                                        write_described_instruction_32(assembly_description, json_32, line, \"111100111010xxxx10x0x00000000001\", code, address)\r\n                                    case \"00000010\":\r\n                                        write_described_instruction_32(assembly_description, json_32, line, \"111100111010xxxx10x0x00000000010\", code, address)\r\n                                    case \"00000011\":\r\n                                        write_described_instruction_32(assembly_description, json_32, line, \"111100111010xxxx10x0x00000000011\", code, address)\r\n                                    case \"00000100\":\r\n                                        write_described_instruction_32(assembly_description, json_32, line, \"111100111010xxxx10x0x00000000100\", code, address)\r\n                                    case _:\r\n                                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                            else:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                        elif line[5:12] == \"0111011\":\r\n                            match line[24:28]:\r\n                                case \"0010\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111100111011xxxx10x0xxxx0010\", code, address)\r\n                                case \"0100\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111100111011xxxx10x0xxxx0100\", code, address)\r\n                                case \"0101\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111100111011xxxx10x0xxxx0101\", code, address)\r\n                                case \"0110\":\r\n                                    write_described_instruction_32(assembly_description, json_32, line, \"111100111011xxxx10x0xxxx0110\", code, address)\r\n                                case _:\r\n                                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                        else:\r\n                            assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                    elif line[17:20] in [\"001\", \"011\"]:\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11110xxxxxxxxxxx10x1\", code, address)\r\n                    elif line[17:20] in [\"101\", \"111\"]:\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11110xxxxxxxxxxx11x1\", code, address)\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # Store single data item\r\n                elif line[:8] == \"11111000\" and line[11] == \"0\":\r\n                    if line[8:12] == \"100\" or (line[8:12] == \"000\" and line[20] == \"1\"):\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000100\", code, address)\r\n                    elif line[8:12] == \"000\" and line[20] == \"0\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000000\", code, address)\r\n                    elif line[8:12] == \"101\" or (line[8:12] == \"001\" and line[20] == \"1\"):\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000101\", code, address)\r\n                    elif line[8:12] == \"001\" and line[20] == \"0\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000001\", code, address)\r\n                    elif line[8:12] == \"110\" or (line[8:12] == \"010\" and line[20] == \"1\"):\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000110\", code, address)\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # STR et LDR\r\n                elif line[:7] == \"1111100\":\r\n                    # Load Byte\r\n                    if line[9:12] == \"001\":\r\n                        if line[7] == \"0\" and line[12:16] == \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11111000x0011111\", code, address)\r\n                        elif (line[7:9] == \"01\" and line[12:16] != \"1111\" and line[16:20] != \"1111\") or (line[7:9] == \"00\" and line[20] == \"1\" and line[23] == \"1\" and line[12:16] != \"1111\") or (line[7:9] == \"00\" and line[20:24] == \"1100\" and line[12:16] != \"1111\" and line[16:20] != \"1111\"):\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110000001\", code, address)\r\n                        elif line[7:9] == \"00\" and line[20:26] == \"000000\" and line[12:16] != \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110000001xxxxxxxx000000\", code, address)\r\n                        elif line[7] == \"1\" and line[12:16] == \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11111001x0011111\", code, address)\r\n                        elif (line[7:9] == \"11\" and line[12:16] != \"1111\" and line[16:20] != \"1111\") or (line[7:9] == \"10\" and line[20] == \"1\" and line[23] == \"1\" and line[12:16] != \"1111\") or (line[7:9] == \"10\" and line[20:24] == \"1100\" and line[12:16] != \"1111\" and line[16:20] != \"1111\"):\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110011001\", code, address)\r\n                        elif line[7:9] == \"10\" and line[20:26] == \"000000\" and line[12:16] != \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110010001\", code, address)\r\n                        elif line[7:9] == \"00\" and line[20:24] == \"1110\" and line[12:16] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110000001xxxxxxxx1110\", code, address)\r\n                        elif (line[7:9] == \"10\" and line[12:16] != \"1111\" and line[16:20] == \"1111\") or (line[7:9] == \"00\" and line[20:24] == \"1100\"and line[12:16] != \"1111\" and line[16:20] == \"1111\") or (line[7] == \"0\" and line[12:16] == \"1111\" and line[16:20] == \"1111\"):\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11111000x00111111111\", code, address)\r\n                        elif line[7:9] == \"00\" and line[20:26] == \"000000\" and line[12:16] != \"1111\" and line[16:20] == \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110000001xxxx1111000000\", code, address)\r\n                        elif (line[7:9] == \"11\" and line[12:16] != \"1111\" and line[16:20] == \"1111\") or (line[7:9] == \"10\" and line[20:24] == \"1100\"and line[12:16] != \"1111\" and line[16:20] == \"1111\") or (line[7] == \"1\" and line[12:16] == \"1111\" and line[16:20] == \"1111\"):\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110011001xxxx1111\", code, address)\r\n                        elif line[7:9] == \"10\" and line[20:26] == \"000000\" and line[12:16] != \"1111\" and line[16:20] == \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110010001xxxx1111000000\", code, address)\r\n                        else:\r\n                            assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                    # Load halfword\r\n                    elif line[9:12] == \"011\":\r\n                        if line[7] == \"0\" and line[12:16] == \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11111000x0111111\", code, address)\r\n                        elif (line[7:9] == \"01\" and line[12:16] != \"1111\" and line[16:20] != \"1111\") or (line[7:9] == \"00\" and line[20] == \"1\" and line[23] == \"1\" and line[12:16] != \"1111\" and line[16:20] != \"1111\") or (line[7:9] == \"00\" and line[20:24] == \"1100\" and line[12:16] != \"1111\" and line[16:20] != \"1111\"):\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110001011xxxxxxxx000000\", code, address)\r\n                        elif line[7:9] == \"00\" and line[20:26] == \"000000\" and line[12:16] != \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110000011\", code, address)\r\n                        elif (line[7:9] == \"11\" and line[12:16] != \"1111\" and line[16:20] != \"1111\") or (line[7:9] == \"10\" and line[20] == \"1\" and line[23] == \"1\" and line[12:16] != \"1111\" and line[16:20] != \"1111\") or (line[7:9] == \"10\" and line[20:24] == \"1100\" and line[12:16] != \"1111\" and line[16:20] != \"1111\"):\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110011011\", code, address)\r\n                        elif line[7] == \"0\" and line[12:16] == \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11111000x011\", code, address)\r\n                        elif line[7:9] == \"10\" and line[20:26] == \"000000\" and line[12:16] != \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110010011\", code, address)\r\n                        elif line[7:9] == \"00\" and line[20:24] == \"1110\" and line[12:16] != \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110000011xxxxxxxx1110\", code, address)\r\n                        elif line[7:9] == \"00\" and line[20:24] == \"1110\" and line[12:16] != \"1111\" and line[16:20] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110010011xxxxxxxx1110\", code, address)\r\n                        else:\r\n                            assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                    # Load word\r\n                    elif line[9:12] == \"101\":\r\n                        if line[7] == \"0\" and line[12:16] == \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"11111000x1011111\", code, address)\r\n                        elif ((line[7:9] == \"01\") or (line[7:9] == \"00\" and line[20] == \"1\" and line[23] == \"1\") or (line[7:9] == \"11\" and line[20:24] == \"1100\")) and line[12:16] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110001101\", code, address)\r\n                        elif line[7:9] == \"01\" and line[20:26] == \"000000\" and line[12:16] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111110001101xxxxxxxx000000\", code, address)\r\n                        elif line[7:9] == \"00\" and line[20:24] == \"1110\" and line[12:16] != \"1111\":\r\n                            write_described_instruction_32(assembly_description, json_32,line, \"111110000101xxxxxxxx1110\", code, address)\r\n                        else:\r\n                            assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # Store single data item\r\n                elif line[:8] == \"11111000\":\r\n                    if (line[8:11] == \"100\") or (line[8:11] == \"000\" and line[20] == \"1\"):\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000100\", code, address)\r\n                    elif line[8:11] == \"000\" and line[20] == \"0\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000000\", code, address)\r\n                    elif (line[8:11] == \"101\") or (line[8:11] == \"001\" and line[20] == \"1\"):\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000101\", code, address)\r\n                    elif line[8:11] == \"001\" and line[20] == \"0\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000001\", code, address)\r\n                    elif (line[8:11] == \"110\") or (line[8:11] == \"010\" and line[20] == \"1\"):\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000110\", code, address)\r\n                    elif line[8:11] == \"010\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"11111000010\", code, address)\r\n                # Data processing (register)\r\n                elif line[:8] == \"11111010\" and line[16:20] == \"1111\":\r\n                    if line[24:28] == \"0000\":\r\n                        match line[8:11]:\r\n                            case \"000\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11111010000\", code, address)\r\n                            case \"001\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11111010001\", code, address)\r\n                            case \"010\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11111010010\", code, address)\r\n                            case \"011\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11111010011\", code, address)\r\n                            case _:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                    elif line[12:16] == \"1111\" and line[24] == \"1\":\r\n                        match line[8:12]:\r\n                            case \"0000\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11111010000011111111xxxx1\", code, address)\r\n                            case \"0001\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11111010000111111111xxxx1\", code, address)\r\n                            case \"0100\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11111010010011111111xxxx1\", code, address)\r\n                            case \"0101\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"11111010010111111111xxxx1\", code, address)\r\n                            case _:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # Miscellaneous operations\r\n                elif line[:10] == \"1111101010\":\r\n                    if line[10:12] == \"01\":\r\n                        match line[26:28]:\r\n                            case \"00\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111110101001xxxx1111xxxx1000\", code, address)\r\n                            case \"01\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111110101001xxxx1111xxxx1001\", code, address)\r\n                            case \"10\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111110101001xxxx1111xxxx1010\", code, address)\r\n                            case \"11\":\r\n                                write_described_instruction_32(assembly_description, json_32, line, \"111110101001xxxx1111xxxx1011\", code, address)\r\n                            case _:\r\n                                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                    elif line[10:12] == \"11\" and line[26:28] == \"00\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110101011\", code, address)\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # Multiply, multiply accumulate, and absolute difference\r\n                elif line[:9] == \"111110110\":\r\n                    if line[9:12] == \"000\" and line[26:28] == \"00\" and line[16:20] == \"1111\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110110000xxxx1111xxxx0000\", code, address)\r\n                    elif line[9:12] == \"000\" and line[26:28] == \"00\" and line[16:20] != \"1111\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110110000xxxxxxxxxxxx0000\", code, address)\r\n                    elif line[9:12] == \"000\" and line[26:28] == \"01\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110110000xxxxxxxxxxxx0001\", code, address)\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # Long multiply, long multiply accumulate, and divide\r\n                elif line[:9] == \"111110111\":\r\n                    if line[9:12] == \"000\" and line[24:28] == \"0000\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110111000xxxxxxxxxxxx0000\", code, address)\r\n                    elif line[9:12] == \"001\" and line[24:28] == \"1111\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110111001xxxxxxxxxxxx1111\", code, address)\r\n                    elif line[9:12] == \"010\" and line[24:28] == \"0000\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110111010xxxxxxxxxxxx0000\", code, address)\r\n                    elif line[9:12] == \"011\" and line[24:28] == \"1111\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110111011xxxxxxxxxxxx1111\", code, address)\r\n                    elif line[9:12] == \"100\" and line[24:28] == \"0000\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110111100xxxxxxxxxxxx0000\", code, address)\r\n                    elif line[9:12] == \"110\" and line[24:28] == \"0000\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111110111110xxxxxxxxxxxx0000\", code, address)\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                # Coprocessor instructions\r\n                elif line[:3] == \"111\" and line[4:6] == \"11\":\r\n                    if line[6] == \"0\" and line[11] == \"0\" and line[6:9] != \"000\" and line[11] != \"0\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111x110xxxx0\", code, address)\r\n                    elif line[6] == \"0\" and line[11] == \"1\" and line[6:9] != \"000\" and line[11] != \"0\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111x110xxxx0\", code, address)\r\n                    elif line[6:12] == \"000100\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111x11000100\", code, address)\r\n                    elif line[6:12] == \"000101\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111x11000101\", code, address)\r\n                    elif line[6:8] == \"10\" and line[27] == \"0\":\r\n                        write_described_instruction_32(assembly_description, json_32, line, \"111x1110xxxxxxxxxxxxxxxxxxx0\", code, address)\r\n                    elif line[6:8] == \"10\" and line[27] == \"1\":\r\n                        if line[11] == \"0\":\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111x1110xxx0xxxxxxxxxxxxxxx1\", code, address)\r\n                        else:\r\n                            write_described_instruction_32(assembly_description, json_32, line, \"111x1110xxx1xxxxxxxxxxxxxxx1\", code, address)\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n                else:\r\n                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED or UNPREDICTABLE\\n\")\r\n        else:  # 16-bits\r\n            # Shift (immediate), add, subtract, move, and compare\r\n            if line[:2] == \"00\":\r\n                if line[2:5] in [\"000\", \"001\", \"010\", \"001\", \"100\", \"101\", \"110\", \"111\"]:\r\n                    write_described_instruction_16(assembly_description, json_16, line, 5, code, address)\r\n                elif line[2:7] in [\"01100\", \"01101\", \"01110\", \"01111\"]:\r\n                    write_described_instruction_16(assembly_description, json_16, line, 7, code, address)\r\n                else:\r\n                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED\\n\")\r\n            # Data processing\r\n            elif line[:6] == \"010000\":\r\n                write_described_instruction_16(assembly_description, json_16, line, 10, code, address)\r\n            # Special data instructions and branch and exchange\r\n            elif line[:6] == \"010001\":\r\n                if line[6:8] in [\"00\", \"10\"]:\r\n                    write_described_instruction_16(assembly_description, json_16, line, 8, code, address)\r\n                elif line[6:9] in [\"011\", \"110\", \"111\"]:\r\n                    write_described_instruction_16(assembly_description, json_16, line, 9, code, address)\r\n                elif line[6:10] == \"0101\":\r\n                    write_described_instruction_16(assembly_description, json_16, line, 10, code, address)\r\n                else:\r\n                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED\\n\")\r\n            # Load / store single data item\r\n            elif line[:4] == \"0101\":\r\n                write_described_instruction_16(assembly_description, json_16, line, 7, code, address)\r\n            # Load / store single data item\r\n            elif line[:4] in [\"0110\", \"0111\", \"1000\", \"1001\"]:\r\n                write_described_instruction_16(assembly_description, json_16, line, 5, code, address)\r\n            # Miscellaneous 16-bit instructions\r\n            elif line[:4] == \"1011\":\r\n                if line[4:11] == \"0110011\":\r\n                    write_described_instruction_16(assembly_description, json_16, line, 11, code, address)\r\n                elif line[4:10] in [\"001000\", \"001001\", \"001010\", \"001011\", \"101000\", \"101001\", \"101011\"]:\r\n                    write_described_instruction_16(assembly_description, json_16, line, 10, code, address)\r\n                elif line[4:9] in [\"00000\", \"00001\"]:\r\n                    write_described_instruction_16(assembly_description, json_16, line, 9, code, address)\r\n                elif line[4:8] in [\"0001\", \"0011\", \"1001\", \"1011\", \"1110\"]:\r\n                    write_described_instruction_16(assembly_description, json_16, line, 8, code, address)\r\n                elif line[4:7] in [\"010\", \"110\"]:\r\n                    write_described_instruction_16(assembly_description, json_16, line, 7, code, address)\r\n                elif line[4:8] == \"1111\":\r\n                    if line[12:16] == \"0000\":\r\n                        if line[8:12] in [\"0000\", \"0001\", \"0010\", \"0011\", \"0100\"]:\r\n                            write_described_instruction_16(assembly_description, json_16, line, 16, code, address)\r\n                        else:\r\n                            assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED\\n\")\r\n                    else:\r\n                        write_described_instruction_16(assembly_description, json_16, line, 8, code, address)\r\n                elif line[:4] == \"1100\":\r\n                    if line[4:8] == \"1111\":\r\n                        write_described_instruction_16(assembly_description, json_16, line, 8, code, address)\r\n                    elif line[4:7] not in [\"1110\", \"1110\"]:\r\n                        write_described_instruction_16(assembly_description, json_16, line, 7, code, address)\r\n                    else:\r\n                        assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED\\n\")\r\n                else:\r\n                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED\\n\")\r\n            elif line[:4] == \"1101\":\r\n                if line[4:8] == \"1111\":\r\n                    write_described_instruction_16(assembly_description, json_16, line, 8, code, address)\r\n                elif line[4:7] != \"111\":\r\n                    write_described_instruction_16(assembly_description, json_16, line, 4, code, address)\r\n                else:\r\n                    assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED\\n\")\r\n            # Unconditional branch, Generate PC-relative address, Generate SP-relative address, Store multiple registers, Load multiple registers, LDR (literal)\r\n            elif line[:5] in [\"11100\", \"10100\", \"10101\", \"11000\", \"11001\", \"01001\"]:\r\n                write_described_instruction_16(assembly_description, json_16, line, 5, code, address)\r\n            else:\r\n                assembly_description.write(\"0x\" + address + \" : \" + line + \" : UNDEFINED\\n\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/conversionHexToAssembly.py b/conversionHexToAssembly.py
--- a/conversionHexToAssembly.py	
+++ b/conversionHexToAssembly.py	
@@ -1,3 +1,7 @@
+# Projet M1
+# Valentin Baudon et Hugo Merle
+# ISEN Nantes
+
 import json
 import math
 import os
Index: ApplicationWindow.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import csv\r\nimport os\r\nimport time\r\n\r\nfrom PyQt5.QtWidgets import QFileDialog, QButtonGroup\r\n\r\nfrom SecondaryWindows import *\r\n\r\n\r\nclass MainWindow(object):\r\n    # Constructeur de la classe\r\n    language = str(locale.getlocale()[0])\r\n\r\n    def __init__(self):\r\n        # Initialisation des attributs de la classe\r\n        self.SConversion = None\r\n        self.SConversion = None\r\n        self.actionSimpleConversion = None\r\n        self.thread = None\r\n        self.selected_hex_file_CSV = None\r\n        self.progressBar = None\r\n        self.DownloadAssemblyInCSVButton = None\r\n        self.nbInstructionsValue = None\r\n        self.nbInstructions = None\r\n        self.InstructionsLayout = None\r\n        self.verticalLayout = None\r\n        self.actionFrancais = None\r\n        self.actionEnglish = None\r\n        self.menuLangues = None\r\n        self.selected_hex_file = None\r\n        self.actionQuitter = None\r\n        self.menuFichier = None\r\n        self.menuFonctionnement = None\r\n        self.actionClearFiles = None\r\n        self.actionNouvellefenetre = None\r\n        self.checked_button = None\r\n        self.button_group = None\r\n        self.explanation = None\r\n        self.about = None\r\n        self.menu_Help = None\r\n        self.menubar = None\r\n        self.DownloadAssemblyButton = None\r\n        self.statusbar = None\r\n        self.DownloadAssemblyButtonLayout = None\r\n        self.actionAbout = None\r\n        self.actionFonctionnement = None\r\n        self.HowToDownloadAssembly_Text = None\r\n        self.line_HautFooter = None\r\n        self.line_RightCenter = None\r\n        self.convertButton = None\r\n        self.FooterLayout = None\r\n        self.ConvertButtonLayout = None\r\n        self.Exemple_OptionConversion = None\r\n        self.IntegralOption = None\r\n        self.ClassiqueOption = None\r\n        self.CompactOption = None\r\n        self.OptionsLayout = None\r\n        self.OptionsGlobalLayout = None\r\n        self.optionConversion_Title = None\r\n        self.DownloadHexButton = None\r\n        self.DownloadHexButtonLayout = None\r\n        self.HowToDownloadHex_Text = None\r\n        self.DownloadHexLayout = None\r\n        self.OptionsConversionLayout = None\r\n        self.line_TextOptions = None\r\n        self.AssemblyCode = None\r\n        self.Assembly_Code_Title = None\r\n        self.HexaCode = None\r\n        self.Hex_Code_Title = None\r\n        self.TextCodesLayout = None\r\n        self.TextCodesGlobalLayout = None\r\n        self.line_LeftText = None\r\n        self.CentralLayout = None\r\n        self.line_TitleCentral = None\r\n        self.Title = None\r\n        self.GlobalLayout = None\r\n        self.centralwidget = None\r\n\r\n        # Initialisation de l'option d'affichage sélectionnée par défaut\r\n        self.selected_button = QtWidgets.QRadioButton()\r\n        self.selected_button.setText(\"Compact\")\r\n\r\n        # Reset des fichiers hexa et assembleur\r\n        with open(resource_path(\"ConversionFiles\\\\Hexa.txt\"), \"w\") as f:\r\n            f.write(\"\")\r\n        f.close()\r\n        with open(resource_path(\"ConversionFiles\\\\Assembly.txt\"), \"w\") as f:\r\n            f.write(\"\")\r\n        f.close()\r\n        with open(resource_path(\"ConversionFiles\\\\Assembly.csv\"), \"w\") as f:\r\n            f.write(\"\")\r\n        f.close()\r\n\r\n        # Gestion de la langue d'affichage par défaut comme étant la même que celle du système de l'utilisateur\r\n        if locale.getlocale()[0] in [\"fr_FR\", \"en_EN\"]:\r\n            self.JSON_lang = json.load(open(resource_path(\"OtherFiles\\\\text_\" + locale.getlocale()[0] + \".json\")))\r\n            self.language = locale.getlocale()[0]\r\n        else:\r\n            self.JSON_lang = json.load(open(resource_path(\"OtherFiles\\\\text_en_EN.json\")))\r\n            self.language = \"en_EN\"\r\n\r\n    # Fonction permettant d'ouvrir la fenêtre \"Fonctionnement\"\r\n    def ExplanationWindow(self):\r\n        self.explanation = Functionning(self.language)\r\n        self.explanation.exec_()\r\n\r\n    # Fonction permettant d'ouvrir la fenêtre \"À propos\"\r\n    def AboutWindow(self):\r\n        self.about = About(self.language)\r\n        self.about.exec_()\r\n\r\n    # Fonction permettant d'ouvrir la fenêtre \"Conversion d'une instruction simple\"\r\n    def SConversionWindow(self):\r\n        self.SConversion = SConversion(self.language)\r\n        self.SConversion.setupUi()\r\n        self.SConversion.exec_()\r\n\r\n    # Fonction qui nettoie les fichiers\r\n    def clearAllFiles(self):\r\n        with open(resource_path(\"ConversionFiles\\\\Hexa.txt\"), \"w\") as f:\r\n            f.write(\"\")\r\n        f.close()\r\n        with open(resource_path(\"ConversionFiles\\\\Assembly.txt\"), \"w\") as f:\r\n            f.write(\"\")\r\n        f.close()\r\n        with open(resource_path(\"ConversionFiles\\\\Assembly.csv\"), \"w\") as f:\r\n            f.write(\"\")\r\n        f.close()\r\n        with open(resource_path(\"ConversionFiles\\\\instructions_file.txt\"), \"w\") as f:\r\n            f.write(\"\")\r\n        f.close()\r\n\r\n        self.HexaCode.setText(\"\")\r\n        self.AssemblyCode.setText(\"\")\r\n\r\n    # Fonction permettant de faire la traduction du fichier hexa et de mettre le résultat dans le fichier \"Assembly.txt\"\r\n    def translate(self):\r\n        self.progressBar.show()\r\n        self.nbInstructionsValue.show()\r\n        self.nbInstructions.show()\r\n        self.thread.start()\r\n        start = time.time()\r\n        writeBinaryInstructions(resource_path(\"ConversionFiles\\\\Hexa.txt\"))\r\n        describe_instructions(self.selected_button.text())\r\n        end = time.time()\r\n\r\n        with open(resource_path(\"ConversionFiles\\\\instructions_file.txt\"), \"r\") as f:\r\n            flines = f.readlines()\r\n            nblignes = len(flines)\r\n        f.close()\r\n\r\n        self.nbInstructionsValue.setText(\r\n            str(nblignes) + \". Execution: \" + str(\"{:.3f}\".format(end - start)) + \"s\")\r\n\r\n        with open(resource_path(\"ConversionFiles\\\\Assembly.txt\"), \"r\") as f:\r\n            assembly_code = f.read()\r\n        f.close()\r\n        self.AssemblyCode.setText(assembly_code)\r\n\r\n    # Fonction permettant de télécharger le contenu d'un fichier hexa présent sur notre ordi qui sera mis dans le fichier \"Hexa.txt\" pour être traîté\r\n    def download_hex_file(self):\r\n        options = QFileDialog.Options()\r\n        options |= QFileDialog.ReadOnly\r\n        file_name, _ = QFileDialog.getOpenFileName(None, \"Sélectionner un fichier .srec\", \"\", \"Fichiers .srec (*.srec);;Tous les fichiers ()\", options=options)\r\n        if file_name:\r\n            hex_name = os.path.basename(file_name).rpartition(\".\")[0]\r\n            newHexName = hex_name + \"_assembly.txt\"\r\n            self.selected_hex_file = newHexName\r\n\r\n            newHexNameCSV = hex_name + \"_assembly.csv\"\r\n            self.selected_hex_file_CSV = newHexNameCSV\r\n\r\n            with open(file_name, \"r\") as f:\r\n                hexa_code = f.read()\r\n            f.close()\r\n            with open(resource_path(\"ConversionFiles\\\\Hexa.txt\"), \"w\") as f:\r\n                f.write(hexa_code)\r\n            f.close()\r\n            self.HexaCode.setText(hexa_code)\r\n\r\n            self.thread = ProgressThread()\r\n            self.thread.progress_signal.connect(self.update_progress)\r\n\r\n    # Fonction permettant de télécharger sur notre ordi le fichier converti en txt\r\n    def download_assembly_file(self):\r\n        options = QFileDialog.Options()\r\n        options |= QFileDialog.ReadOnly\r\n        file_name, _ = QFileDialog.getSaveFileName(None, \"Enregistrer le fichier Assembly.txt\", self.selected_hex_file, \"Tous les fichiers ()\", options=options)\r\n        if file_name:\r\n            with open(resource_path(\"ConversionFiles\\\\Assembly.txt\"), \"r\") as f:\r\n                assembly_code = f.read()\r\n            f.close()\r\n            with open(file_name, \"w\") as f:\r\n                f.write(assembly_code)\r\n            f.close()\r\n\r\n    # Fonction permettant de télécharger sur notre ordi le fichier converti en csv\r\n    def download_csv_file(self):\r\n        with open(resource_path(\"ConversionFiles\\\\Assembly.csv\"), mode=\"w\", newline='') as f:\r\n            writer = csv.writer(f, delimiter=';')\r\n            match self.selected_button.text():\r\n                case \"Compact\":\r\n                    header = [\"address\", \"instruction\", \"values\"]\r\n                case \"Classique\":\r\n                    header = [\"address\", \"meaning\", \"values\"]\r\n                case \"Classic\":\r\n                    header = [\"address\", \"meaning\", \"values\"]\r\n                case \"Integral\":\r\n                    header = [\"address\", \"bits\", \"meaning\", \"values\"]\r\n            writer.writerow(header)\r\n            assembly = open(\"ConversionFiles\\\\Assembly.txt\")\r\n            lines = assembly.readlines()\r\n            assembly.close()\r\n            for line in lines:\r\n                arguments = line[:-1].split(\" : \")\r\n                match len(arguments):\r\n                    case 2:\r\n                        writer.writerow([arguments[0], arguments[1]])\r\n                    case 3:\r\n                        writer.writerow([arguments[0], arguments[1], arguments[2]])\r\n                    case 4:\r\n                        writer.writerow([arguments[0], str(arguments[1]), arguments[2], arguments[3]])\r\n        f.close()\r\n\r\n        options = QFileDialog.Options()\r\n        options |= QFileDialog.ReadOnly\r\n        file_name, _ = QFileDialog.getSaveFileName(None, \"Enregistrer le fichier Assembly.csv\",\r\n                                                   self.selected_hex_file_CSV, \"Tous les fichiers ()\", options=options)\r\n        if file_name:\r\n            with open(resource_path(\"ConversionFiles\\\\Assembly.csv\"), \"r\") as f:\r\n                assembly_code = f.read()\r\n            f.close()\r\n            with open(file_name, \"w\") as f:\r\n                f.write(assembly_code)\r\n            f.close()\r\n\r\n    # Fonction permettant de mettre à jour le bouton d'option d'affichage sélectionnée\r\n    def store_selection(self, button):\r\n        self.selected_button = button\r\n\r\n    # Fonction permettant de changer la langue d'affichage en français\r\n    def select_language_fr(self):\r\n        self.JSON_lang = json.load(open(resource_path(\"OtherFiles\\\\text_fr_FR.json\")))\r\n        self.NameInit()\r\n        self.language = \"fr_FR\"\r\n        self.actionEnglish.setChecked(False)\r\n        self.actionFrancais.setChecked(True)\r\n        self.clearAllFiles()\r\n        self.nbInstructions.hide()\r\n        self.nbInstructionsValue.hide()\r\n        self.progressBar.hide()\r\n\r\n    # Fonction permettant de changer la langue d'affichage en anglais\r\n    def select_language_en(self):\r\n        self.JSON_lang = json.load(open(resource_path(\"OtherFiles\\\\text_en_EN.json\")))\r\n        self.NameInit()\r\n        self.language = \"en_EN\"\r\n        self.actionFrancais.setChecked(False)\r\n        self.actionEnglish.setChecked(True)\r\n        self.clearAllFiles()\r\n        self.nbInstructions.hide()\r\n        self.nbInstructionsValue.hide()\r\n        self.progressBar.hide()\r\n\r\n    # Partie initialisation des textes et noms des éléments de la fenêtre\r\n    def NameInit(self):\r\n        _translate = QtCore.QCoreApplication.translate\r\n        self.Title.setText(_translate(\"Converter\", self.JSON_lang[\"Title\"]))\r\n        self.Hex_Code_Title.setText(_translate(\"Converter\", self.JSON_lang[\"Hex_Code_Title\"]))\r\n        self.Assembly_Code_Title.setText(_translate(\"Converter\", self.JSON_lang[\"Assembly_Code_Title\"]))\r\n        self.HowToDownloadHex_Text.setText(_translate(\"Converter\", self.JSON_lang[\"HowToDownloadHex_Text\"]))\r\n        self.DownloadHexButton.setText(_translate(\"Converter\", self.JSON_lang[\"DownloadHexButton\"]))\r\n        self.optionConversion_Title.setText(_translate(\"Converter\", self.JSON_lang[\"optionConversion_Title\"]))\r\n        self.CompactOption.setText(_translate(\"Converter\", self.JSON_lang[\"CompactOption\"]))\r\n        self.ClassiqueOption.setText(_translate(\"Converter\", self.JSON_lang[\"ClassiqueOption\"]))\r\n        self.IntegralOption.setText(_translate(\"Converter\", self.JSON_lang[\"IntegralOption\"]))\r\n        self.Exemple_OptionConversion.setText(_translate(\"Converter\", self.JSON_lang[\"Exemple_OptionConversion\"]))\r\n        self.convertButton.setText(_translate(\"Converter\", self.JSON_lang[\"convertButton\"]))\r\n        self.nbInstructions.setText(_translate(\"Converter\", self.JSON_lang[\"nbInstructions\"]))\r\n        self.nbInstructionsValue.setText(_translate(\"Converter\", self.JSON_lang[\"nbInstructionsValue\"]))\r\n        self.HowToDownloadAssembly_Text.setText(_translate(\"Converter\", self.JSON_lang[\"HowToDownloadAssembly_Text\"]))\r\n        self.DownloadAssemblyButton.setText(_translate(\"Converter\", self.JSON_lang[\"DownloadAssemblyButton\"]))\r\n        self.DownloadAssemblyInCSVButton.setText(_translate(\"Converter\", self.JSON_lang[\"DownloadAssemblyInCSVButton\"]))\r\n        self.menu_Help.setTitle(_translate(\"Converter\", self.JSON_lang[\"menu_Help\"]))\r\n        self.menuFonctionnement.setTitle(_translate(\"Converter\", self.JSON_lang[\"menuFonctionnement\"]))\r\n        self.menuFichier.setTitle(_translate(\"Converter\", self.JSON_lang[\"menuFichier\"]))\r\n        self.menuLangues.setTitle(_translate(\"Converter\", self.JSON_lang[\"menuLangues\"]))\r\n        self.actionAbout.setText(_translate(\"Converter\", self.JSON_lang[\"actionAbout\"]))\r\n        self.actionFonctionnement.setText(_translate(\"Converter\", self.JSON_lang[\"actionFonctionnement\"]))\r\n        self.actionClearFiles.setText(_translate(\"Converter\", self.JSON_lang[\"actionClearFiles\"]))\r\n        self.actionQuitter.setText(_translate(\"Converter\", self.JSON_lang[\"actionQuitter\"]))\r\n        self.actionFrancais.setText(_translate(\"Converter\", self.JSON_lang[\"actionFrancais\"]))\r\n        self.actionEnglish.setText(_translate(\"Converter\", self.JSON_lang[\"actionEnglish\"]))\r\n        self.actionSimpleConversion.setText(_translate(\"Converter\", self.JSON_lang[\"actionSimpleConversion\"]))\r\n\r\n    # Fonction qui met à jour la valeur de la barre de progression\r\n    def update_progress(self, val):\r\n        self.progressBar.setValue(val)\r\n\r\n    # Fonction de définition des composants de notre fenêtre principale\r\n    def setupUi(self, ConverterWindow):\r\n        # Paramètres généraux de la fenêtre\r\n        ConverterWindow.setObjectName(\"HexaToAssemblyConverter\")\r\n        ConverterWindow.resize(1216, 842)\r\n        ConverterWindow.setWindowState(QtCore.Qt.WindowMaximized)\r\n        icon = QIcon(resource_path(\"graphicResources\\\\TemporaryIcon.ico\"))\r\n        ConverterWindow.setWindowIcon(icon)\r\n\r\n        # Initialisation de polices utilisées\r\n        font = QtGui.QFont()\r\n        font.setPointSize(15)\r\n        font2 = QtGui.QFont()\r\n        font2.setPointSize(9)\r\n        font3 = QtGui.QFont()\r\n        font3.setPointSize(9)\r\n        font3.setBold(False)\r\n        font3.setWeight(50)\r\n        font4 = QtGui.QFont()\r\n        font4.setPointSize(12)\r\n        font5 = QtGui.QFont()\r\n        font5.setPointSize(25)\r\n\r\n        # Objet central\r\n        self.centralwidget = QtWidgets.QWidget(ConverterWindow)\r\n        self.centralwidget.setObjectName(\"centralwidget\")\r\n        ConverterWindow.setCentralWidget(self.centralwidget)\r\n\r\n        # Layout global\r\n        self.GlobalLayout = QtWidgets.QVBoxLayout(self.centralwidget)\r\n        self.GlobalLayout.setObjectName(\"GlobalLayout\")\r\n\r\n        # Titre de la page\r\n        self.Title = QtWidgets.QLabel(self.centralwidget)\r\n        self.Title.setFont(font)\r\n        self.Title.setAlignment(QtCore.Qt.AlignHCenter | QtCore.Qt.AlignTop)\r\n        self.Title.setObjectName(\"Title\")\r\n        self.GlobalLayout.addWidget(self.Title)\r\n\r\n        # Spacer entre le titre et la partie centrale\r\n        spacerItem = QtWidgets.QSpacerItem(17, 17, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)\r\n        self.GlobalLayout.addItem(spacerItem)\r\n\r\n        # Ligne entre le titre et la partie centrale\r\n        self.line_TitleCentral = QtWidgets.QFrame(self.centralwidget)\r\n        self.line_TitleCentral.setFrameShape(QtWidgets.QFrame.HLine)\r\n        self.line_TitleCentral.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line_TitleCentral.setObjectName(\"line_TitleCentral\")\r\n        self.GlobalLayout.addWidget(self.line_TitleCentral)\r\n\r\n        # Layout de la partie centrale\r\n        self.CentralLayout = QtWidgets.QHBoxLayout()\r\n        self.CentralLayout.setObjectName(\"CentralLayout\")\r\n\r\n        # Ligne à gauche de la partie texte\r\n        self.line_LeftText = QtWidgets.QFrame(self.centralwidget)\r\n        self.line_LeftText.setFrameShape(QtWidgets.QFrame.VLine)\r\n        self.line_LeftText.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line_LeftText.setObjectName(\"line_LeftText\")\r\n        self.CentralLayout.addWidget(self.line_LeftText)\r\n\r\n        # Layout global de la partie d'affichage des codes\r\n        self.TextCodesGlobalLayout = QtWidgets.QWidget(self.centralwidget)\r\n        self.TextCodesGlobalLayout.setObjectName(\"TextCodesGlobalLayout\")\r\n\r\n        # Layout de la partie d'affichage des codes\r\n        self.TextCodesLayout = QtWidgets.QVBoxLayout(self.TextCodesGlobalLayout)\r\n        self.TextCodesLayout.setObjectName(\"TextCodesLayout\")\r\n\r\n        # Objet titre du texte en hexadecimal\r\n        self.Hex_Code_Title = QtWidgets.QLabel(self.TextCodesGlobalLayout)\r\n        self.Hex_Code_Title.setFont(font)\r\n        self.Hex_Code_Title.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.Hex_Code_Title.setObjectName(\"Hex_Code_Title\")\r\n        self.TextCodesLayout.addWidget(self.Hex_Code_Title)\r\n\r\n        # Objet texte en hexadecimal\r\n        self.HexaCode = QtWidgets.QTextEdit(self.TextCodesGlobalLayout)\r\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Maximum)\r\n        sizePolicy.setHorizontalStretch(0)\r\n        sizePolicy.setVerticalStretch(0)\r\n        sizePolicy.setHeightForWidth(self.HexaCode.sizePolicy().hasHeightForWidth())\r\n        self.HexaCode.setSizePolicy(sizePolicy)\r\n        self.HexaCode.setMaximumSize(QtCore.QSize(16777215, 400))\r\n        self.HexaCode.setReadOnly(True)\r\n        self.HexaCode.setObjectName(\"HexaCode\")\r\n        self.TextCodesLayout.addWidget(self.HexaCode)\r\n\r\n        # Objet titre du texte en assembleur\r\n        self.Assembly_Code_Title = QtWidgets.QLabel(self.TextCodesGlobalLayout)\r\n        self.Assembly_Code_Title.setFont(font)\r\n        self.Assembly_Code_Title.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.Assembly_Code_Title.setObjectName(\"Assembly_Code_Title\")\r\n        self.TextCodesLayout.addWidget(self.Assembly_Code_Title)\r\n\r\n        # Objet texte en assembleur\r\n        self.AssemblyCode = QtWidgets.QTextEdit(self.TextCodesGlobalLayout)\r\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Maximum)\r\n        sizePolicy.setHorizontalStretch(0)\r\n        sizePolicy.setVerticalStretch(0)\r\n        sizePolicy.setHeightForWidth(self.AssemblyCode.sizePolicy().hasHeightForWidth())\r\n        self.AssemblyCode.setSizePolicy(sizePolicy)\r\n        self.AssemblyCode.setMinimumSize(QtCore.QSize(300, 400))\r\n        self.AssemblyCode.setObjectName(\"AssemblyCode\")\r\n        self.AssemblyCode.setFont(font4)\r\n        self.AssemblyCode.setReadOnly(True)\r\n        self.TextCodesLayout.addWidget(self.AssemblyCode)\r\n        self.CentralLayout.addWidget(self.TextCodesGlobalLayout)\r\n\r\n        # Ligne entre la partie texte et la partie options et conversion\r\n        self.line_TextOptions = QtWidgets.QFrame(self.centralwidget)\r\n        self.line_TextOptions.setFrameShape(QtWidgets.QFrame.VLine)\r\n        self.line_TextOptions.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line_TextOptions.setObjectName(\"line_TextOptions\")\r\n        self.CentralLayout.addWidget(self.line_TextOptions)\r\n\r\n        # Layout partie options et conversion\r\n        self.OptionsConversionLayout = QtWidgets.QVBoxLayout()\r\n        self.OptionsConversionLayout.setObjectName(\"OptionsConversionLayout\")\r\n\r\n        # Layout partie téléchargement fichier hexa\r\n        self.DownloadHexLayout = QtWidgets.QVBoxLayout()\r\n        self.DownloadHexLayout.setObjectName(\"DownloadHexLayout\")\r\n\r\n        # Spacer entre haut de partie centrale et layout partie téléchargement fichier hexa\r\n        spacer_HighCentral_DownloadHexLayout = QtWidgets.QSpacerItem(17, 17, QtWidgets.QSizePolicy.Minimum,\r\n                                                                     QtWidgets.QSizePolicy.Fixed)\r\n        self.DownloadHexLayout.addItem(spacer_HighCentral_DownloadHexLayout)\r\n\r\n        # Objet texte indication téléchargement hexa\r\n        self.HowToDownloadHex_Text = QtWidgets.QLabel(self.centralwidget)\r\n        self.HowToDownloadHex_Text.setFont(font)\r\n        self.HowToDownloadHex_Text.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.HowToDownloadHex_Text.setObjectName(\"HowToDownloadHex_Text\")\r\n        self.DownloadHexLayout.addWidget(self.HowToDownloadHex_Text)\r\n\r\n        # Layout autour du bouton de téléchargement du fichier hexa\r\n        self.DownloadHexButtonLayout = QtWidgets.QHBoxLayout()\r\n        self.DownloadHexButtonLayout.setObjectName(\"DownloadHexButtonLayout\")\r\n\r\n        # Spacer entre gauche partie conversion et bouton conversion\r\n        spacer_LeftConversion_DownloadHexButton = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                                        QtWidgets.QSizePolicy.Minimum)\r\n        self.DownloadHexButtonLayout.addItem(spacer_LeftConversion_DownloadHexButton)\r\n\r\n        # Bouton de téléchargement du fichier hexa\r\n        self.DownloadHexButton = QtWidgets.QPushButton(self.centralwidget)\r\n        self.DownloadHexButton.setMaximumSize(QtCore.QSize(200, 16777215))\r\n        self.DownloadHexButton.setFont(font2)\r\n        self.DownloadHexButton.setLayoutDirection(QtCore.Qt.LeftToRight)\r\n        self.DownloadHexButton.setObjectName(\"DownloadHexButton\")\r\n        self.DownloadHexButtonLayout.addWidget(self.DownloadHexButton)\r\n\r\n        # Spacer entre droite partie conversion et bouton conversion\r\n        spacer_RightConversion_DownloadHexButton = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                                         QtWidgets.QSizePolicy.Minimum)\r\n        self.DownloadHexButtonLayout.addItem(spacer_RightConversion_DownloadHexButton)\r\n        self.DownloadHexLayout.addLayout(self.DownloadHexButtonLayout)\r\n        self.OptionsConversionLayout.addLayout(self.DownloadHexLayout)\r\n\r\n        # Spacer entre téléchargement hexa et options d'affichage\r\n        spacer_OptionAffichage_DownloadHexButton = QtWidgets.QSpacerItem(17, 13, QtWidgets.QSizePolicy.Minimum,\r\n                                                                         QtWidgets.QSizePolicy.Expanding)\r\n        self.OptionsConversionLayout.addItem(spacer_OptionAffichage_DownloadHexButton)\r\n\r\n        # Titre de la partie sélection d'options d'affichage\r\n        self.optionConversion_Title = QtWidgets.QLabel(self.centralwidget)\r\n        self.optionConversion_Title.setFont(font)\r\n        self.optionConversion_Title.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.optionConversion_Title.setObjectName(\"optionConversion_Title\")\r\n        self.OptionsConversionLayout.addWidget(self.optionConversion_Title)\r\n\r\n        # Layout global partie options d'affichage\r\n        self.OptionsGlobalLayout = QtWidgets.QHBoxLayout()\r\n        self.OptionsGlobalLayout.setObjectName(\"OptionsGlobalLayout\")\r\n\r\n        # Spacer à gauche des options d'affichage\r\n        spacerLeftOptionsConversion = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                            QtWidgets.QSizePolicy.Minimum)\r\n        self.OptionsGlobalLayout.addItem(spacerLeftOptionsConversion)\r\n\r\n        # Layout contenant les boutons d'options d'affichage\r\n        self.OptionsLayout = QtWidgets.QVBoxLayout()\r\n        self.OptionsLayout.setObjectName(\"OptionsLayout\")\r\n        self.button_group = QButtonGroup()\r\n\r\n        # Bouton option d'affichage compact\r\n        self.CompactOption = QtWidgets.QRadioButton(self.centralwidget)\r\n        self.CompactOption.setFont(font)\r\n        self.CompactOption.setObjectName(\"CompactOption\")\r\n        self.OptionsLayout.addWidget(self.CompactOption)\r\n        self.button_group.addButton(self.CompactOption)\r\n        self.CompactOption.setChecked(True)\r\n\r\n        # Bouton option d'affichage classique\r\n        self.ClassiqueOption = QtWidgets.QRadioButton(self.centralwidget)\r\n        self.ClassiqueOption.setFont(font)\r\n        self.ClassiqueOption.setObjectName(\"ClassiqueOption\")\r\n        self.OptionsLayout.addWidget(self.ClassiqueOption)\r\n        self.button_group.addButton(self.ClassiqueOption)\r\n\r\n        # Bouton option d'affichage intégral\r\n        self.IntegralOption = QtWidgets.QRadioButton(self.centralwidget)\r\n        self.IntegralOption.setFont(font)\r\n        self.IntegralOption.setObjectName(\"IntegralOption\")\r\n        self.OptionsLayout.addWidget(self.IntegralOption)\r\n        self.button_group.addButton(self.IntegralOption)\r\n        self.checked_button = self.button_group.checkedButton()\r\n        self.OptionsGlobalLayout.addLayout(self.OptionsLayout)\r\n\r\n        # Spacer entre droite partie conversion et options d'affichage\r\n        spacer_RightConversion_OptionAffichage = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                                       QtWidgets.QSizePolicy.Minimum)\r\n        self.OptionsGlobalLayout.addItem(spacer_RightConversion_OptionAffichage)\r\n        self.OptionsConversionLayout.addLayout(self.OptionsGlobalLayout)\r\n\r\n        # Spacer entre gauche partie conversion et options d'affichage\r\n        spacer_LeftConversion_OptionAffichage = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum,\r\n                                                                      QtWidgets.QSizePolicy.Expanding)\r\n        self.OptionsConversionLayout.addItem(spacer_LeftConversion_OptionAffichage)\r\n\r\n        # Texte exemple options d'affichage\r\n        self.Exemple_OptionConversion = QtWidgets.QLabel(self.centralwidget)\r\n        self.Exemple_OptionConversion.setFont(font4)\r\n        self.Exemple_OptionConversion.setAlignment(\r\n            QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\r\n        self.Exemple_OptionConversion.setWordWrap(False)\r\n        self.Exemple_OptionConversion.setObjectName(\"Exemple_OptionConversion\")\r\n        self.OptionsConversionLayout.addWidget(self.Exemple_OptionConversion)\r\n\r\n        # Spacer entre haut bouton conversion et options d'affichage\r\n        spacer_ConvertButton_OptionAffichage = QtWidgets.QSpacerItem(17, 13, QtWidgets.QSizePolicy.Minimum,\r\n                                                                     QtWidgets.QSizePolicy.Expanding)\r\n        self.OptionsConversionLayout.addItem(spacer_ConvertButton_OptionAffichage)\r\n\r\n        # Layout autour du bouton de conversion\r\n        self.ConvertButtonLayout = QtWidgets.QHBoxLayout()\r\n        self.ConvertButtonLayout.setObjectName(\"ConvertButtonLayout\")\r\n\r\n        # Spacer bas bouton conversion\r\n        spacer_lowConvertButton = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                        QtWidgets.QSizePolicy.Minimum)\r\n        self.ConvertButtonLayout.addItem(spacer_lowConvertButton)\r\n\r\n        # Bouton de conversion\r\n        self.convertButton = QtWidgets.QPushButton(self.centralwidget)\r\n        self.convertButton.setMaximumSize(QtCore.QSize(200, 16777215))\r\n        self.convertButton.setFont(font5)\r\n        self.convertButton.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)\r\n        self.convertButton.setObjectName(\"convertButton\")\r\n        self.ConvertButtonLayout.addWidget(self.convertButton)\r\n\r\n        # Spacer droite bouton conversion\r\n        spacer_RightConvertButton = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                          QtWidgets.QSizePolicy.Minimum)\r\n        self.ConvertButtonLayout.addItem(spacer_RightConvertButton)\r\n        self.OptionsConversionLayout.addLayout(self.ConvertButtonLayout)\r\n\r\n        # Spacer gauche bouton conversion\r\n        spacer_LeftConvertButton = QtWidgets.QSpacerItem(17, 13, QtWidgets.QSizePolicy.Minimum,\r\n                                                         QtWidgets.QSizePolicy.Expanding)\r\n        self.OptionsConversionLayout.addItem(spacer_LeftConvertButton)\r\n        self.CentralLayout.addLayout(self.OptionsConversionLayout)\r\n\r\n        # layout affichage du nombre d'instructions\r\n        self.InstructionsLayout = QtWidgets.QHBoxLayout()\r\n        self.InstructionsLayout.setObjectName(\"InstructionsLayout\")\r\n\r\n        # texte nombre d'instructions\r\n        self.nbInstructions = QtWidgets.QLabel(self.centralwidget)\r\n        self.nbInstructions.setFont(font2)\r\n        self.nbInstructions.setWordWrap(False)\r\n        self.nbInstructions.setObjectName(\"nbInstructions\")\r\n        self.nbInstructions.hide()\r\n        self.InstructionsLayout.addWidget(self.nbInstructions)\r\n\r\n        # valeur nombre d'instructions\r\n        self.nbInstructionsValue = QtWidgets.QLabel(self.centralwidget)\r\n        self.nbInstructionsValue.setFont(font2)\r\n        self.nbInstructionsValue.setWordWrap(False)\r\n        self.nbInstructionsValue.setObjectName(\"nbInstructions\")\r\n        self.nbInstructionsValue.hide()\r\n        self.InstructionsLayout.addWidget(self.nbInstructionsValue)\r\n\r\n        # Spacer à droite du nombre d'instructions\r\n        spacerRightNbInstruction = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                         QtWidgets.QSizePolicy.Minimum)\r\n        self.InstructionsLayout.addItem(spacerRightNbInstruction)\r\n\r\n        # Barre de progression de la conversion\r\n        self.progressBar = QtWidgets.QProgressBar(self.centralwidget)\r\n        self.progressBar.setObjectName(\"progressBar\")\r\n        self.progressBar.hide()\r\n        self.InstructionsLayout.addWidget(self.progressBar)\r\n\r\n        self.OptionsConversionLayout.addItem(self.InstructionsLayout)\r\n\r\n        # Ligne à droite de l'application\r\n        self.line_RightCenter = QtWidgets.QFrame(self.centralwidget)\r\n        self.line_RightCenter.setFrameShape(QtWidgets.QFrame.VLine)\r\n        self.line_RightCenter.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line_RightCenter.setObjectName(\"line_RightCenter\")\r\n        self.CentralLayout.addWidget(self.line_RightCenter)\r\n        self.GlobalLayout.addLayout(self.CentralLayout)\r\n\r\n        # Layout de la partie basse de l'application\r\n        self.FooterLayout = QtWidgets.QVBoxLayout()\r\n        self.FooterLayout.setObjectName(\"FooterLayout\")\r\n\r\n        # Ligne entre le footer et le reste de l'application\r\n        self.line_HautFooter = QtWidgets.QFrame(self.centralwidget)\r\n        self.line_HautFooter.setFrameShape(QtWidgets.QFrame.HLine)\r\n        self.line_HautFooter.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line_HautFooter.setObjectName(\"line_HautFooter\")\r\n        self.FooterLayout.addWidget(self.line_HautFooter)\r\n\r\n        # Spacer entre line_HautFooter et le footer\r\n        spacer_HautFooter = QtWidgets.QSpacerItem(17, 17, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)\r\n        self.FooterLayout.addItem(spacer_HautFooter)\r\n\r\n        # Objet texte indication téléchargement assembleur\r\n        self.HowToDownloadAssembly_Text = QtWidgets.QLabel(self.centralwidget)\r\n        self.HowToDownloadAssembly_Text.setFont(font)\r\n        self.HowToDownloadAssembly_Text.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.HowToDownloadAssembly_Text.setObjectName(\"HowToDownloadAssembly_Text\")\r\n        self.FooterLayout.addWidget(self.HowToDownloadAssembly_Text)\r\n\r\n        # Spacer entre titre footer et boutons de téléchargement\r\n        spacer_CentreFooter = QtWidgets.QSpacerItem(17, 17, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)\r\n        self.FooterLayout.addItem(spacer_CentreFooter)\r\n\r\n        # Layout autour du bouton de téléchargement de l'assembleur\r\n        self.DownloadAssemblyButtonLayout = QtWidgets.QHBoxLayout()\r\n        self.DownloadAssemblyButtonLayout.setObjectName(\"DownloadAssemblyButtonLayout\")\r\n\r\n        # Spacer gauche bouton DownloadAssembly\r\n        spacer_leftDownloadAssemblyText = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                                QtWidgets.QSizePolicy.Minimum)\r\n        self.DownloadAssemblyButtonLayout.addItem(spacer_leftDownloadAssemblyText)\r\n\r\n        # Bouton de téléchargement de l'assembleur en fichier texte\r\n        self.DownloadAssemblyButton = QtWidgets.QPushButton(self.centralwidget)\r\n        self.DownloadAssemblyButton.setMaximumSize(QtCore.QSize(400, 16777215))\r\n        self.DownloadAssemblyButton.setFont(font2)\r\n        self.DownloadAssemblyButton.setObjectName(\"DownloadAssemblyButton\")\r\n        self.DownloadAssemblyButtonLayout.addWidget(self.DownloadAssemblyButton)\r\n\r\n        # Spacer entre les 2 boutons DownloadAssembly\r\n        spacer_BetweenDownloadAssembly = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                               QtWidgets.QSizePolicy.Minimum)\r\n        self.DownloadAssemblyButtonLayout.addItem(spacer_BetweenDownloadAssembly)\r\n\r\n        # Bouton de téléchargement de l'assembleur en fichier CSV\r\n        self.DownloadAssemblyInCSVButton = QtWidgets.QPushButton(self.centralwidget)\r\n        self.DownloadAssemblyInCSVButton.setFont(font2)\r\n        self.DownloadAssemblyInCSVButton.setObjectName(\"DownloadAssemblyInCSVButton\")\r\n        self.DownloadAssemblyButtonLayout.addWidget(self.DownloadAssemblyInCSVButton)\r\n\r\n        # Spacer droite bontons DownloadAssembly\r\n        spacer_RightDownloadAssemblyCSV = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding,\r\n                                                                QtWidgets.QSizePolicy.Minimum)\r\n        self.DownloadAssemblyButtonLayout.addItem(spacer_RightDownloadAssemblyCSV)\r\n\r\n        self.FooterLayout.addLayout(self.DownloadAssemblyButtonLayout)\r\n        self.GlobalLayout.addLayout(self.FooterLayout)\r\n\r\n        # PARTIE BARRE DE MENU\r\n\r\n        # Initialisation de la barre de menu\r\n        self.menubar = QtWidgets.QMenuBar(ConverterWindow)\r\n        self.menubar.setGeometry(QtCore.QRect(0, 0, 1216, 26))\r\n        self.menubar.setObjectName(\"menubar\")\r\n\r\n        # Initialisation des parties de la barre de menu\r\n        self.menu_Help = QtWidgets.QMenu(self.menubar)\r\n        self.menu_Help.setObjectName(\"menu_Help\")\r\n        self.menuFonctionnement = QtWidgets.QMenu(self.menubar)\r\n        self.menuFonctionnement.setObjectName(\"menuFonctionnement\")\r\n        self.menuFichier = QtWidgets.QMenu(self.menubar)\r\n        self.menuFichier.setObjectName(\"menuFichier\")\r\n        self.menuLangues = QtWidgets.QMenu(self.menuFichier)\r\n        self.menuLangues.setIcon(QIcon(\"graphicResources\\\\LanguagesLogo.png\"))\r\n        self.menuLangues.setObjectName(\"menuLangues\")\r\n        ConverterWindow.setMenuBar(self.menubar)\r\n        self.statusbar = QtWidgets.QStatusBar(ConverterWindow)\r\n        self.statusbar.setObjectName(\"statusbar\")\r\n        ConverterWindow.setStatusBar(self.statusbar)\r\n\r\n        # Création de l'action liée à la fenêtre \"à propos\"\r\n        self.actionAbout = QtWidgets.QAction(ConverterWindow)\r\n        self.actionAbout.setIcon(QIcon(\"graphicResources\\\\AboutLogo.png\"))\r\n        self.actionAbout.setObjectName(\"actionAbout\")\r\n\r\n        # Création de l'action liée à la fenêtre \"fonctionnement\"\r\n        self.actionFonctionnement = QtWidgets.QAction(ConverterWindow)\r\n        self.actionFonctionnement.setIcon(QIcon(\"graphicResources\\\\ExplanationLogo.png\"))\r\n        self.actionFonctionnement.setObjectName(\"actionFonctionnement\")\r\n\r\n        # Création de l'action liée à la fenêtre \"fonctionnement\"\r\n        self.actionSimpleConversion = QtWidgets.QAction(ConverterWindow)\r\n        self.actionSimpleConversion.setIcon(QIcon(\"graphicResources\\\\SC_logo.png\"))\r\n        self.actionSimpleConversion.setObjectName(\"actionSimpleConversion\")\r\n\r\n        # Création de l'action liée au sous menu \"nettoyer les fichiers\"\r\n        self.actionClearFiles = QtWidgets.QAction(ConverterWindow)\r\n        self.actionClearFiles.setIcon(QIcon(\"graphicResources\\\\cleanFilesLogo.png\"))\r\n        self.actionClearFiles.setObjectName(\"actionClearFiles\")\r\n\r\n        # Création de l'action liée au sous menu \"quitter\"\r\n        self.actionQuitter = QtWidgets.QAction(ConverterWindow)\r\n        self.actionQuitter.setIcon(QIcon(\"graphicResources\\\\QuitLogo.png\"))\r\n        self.actionQuitter.setObjectName(\"actionQuitter\")\r\n\r\n        # Création de l'action liée au sous sous-menu \"changer la langue en français\"\r\n        self.actionFrancais = QtWidgets.QAction(ConverterWindow)\r\n        self.actionFrancais.setObjectName(\"actionFrancais\")\r\n        self.actionFrancais.setCheckable(True)\r\n\r\n        # Création de l'action liée au sous sous-menu \"changer la langue en anglais\"\r\n        self.actionEnglish = QtWidgets.QAction(ConverterWindow)\r\n        self.actionEnglish.setObjectName(\"actionEnglish\")\r\n        self.actionEnglish.setCheckable(True)\r\n\r\n        # Liaison entre les actions créée et les menus et sous menus\r\n        self.menu_Help.addAction(self.actionFonctionnement)\r\n        self.menu_Help.addAction(self.actionAbout)\r\n        self.menuFonctionnement.addAction(self.actionSimpleConversion)\r\n        self.menuFichier.addAction(self.actionClearFiles)\r\n        self.menuLangues.addAction(self.actionFrancais)\r\n        self.menuLangues.addAction(self.actionEnglish)\r\n        self.menuFichier.addAction(self.menuLangues.menuAction())\r\n        self.menuFichier.addAction(self.actionQuitter)\r\n        self.menubar.addAction(self.menuFichier.menuAction())\r\n        self.menubar.addAction(self.menuFonctionnement.menuAction())\r\n        self.menubar.addAction(self.menu_Help.menuAction())\r\n\r\n        # sélection de la langue à cocher\r\n        if self.language == \"fr_FR\":\r\n            self.actionFrancais.setChecked(True)\r\n        elif self.language == \"en_EN\":\r\n            self.actionEnglish.setChecked(True)\r\n\r\n        # Partie connexion aux actions quand clic de l'utilisateur\r\n        self.button_group.buttonClicked.connect(self.store_selection)\r\n        self.convertButton.clicked.connect(self.translate)\r\n        self.DownloadHexButton.clicked.connect(self.download_hex_file)\r\n        self.DownloadAssemblyButton.clicked.connect(self.download_assembly_file)\r\n        self.DownloadAssemblyInCSVButton.clicked.connect(self.download_csv_file)\r\n        self.actionFonctionnement.triggered.connect(self.ExplanationWindow)\r\n        self.actionAbout.triggered.connect(self.AboutWindow)\r\n        self.actionSimpleConversion.triggered.connect(self.SConversionWindow)\r\n        self.actionFrancais.triggered.connect(self.select_language_fr)\r\n        self.actionEnglish.triggered.connect(self.select_language_en)\r\n        self.actionClearFiles.triggered.connect(self.clearAllFiles)\r\n        self.actionQuitter.triggered.connect(ConverterWindow.close)\r\n\r\n        # Affichage du fichier \"Hexa.txt\" dans la partie correpondante\r\n        with open(resource_path(\"ConversionFiles\\\\Hexa.txt\"), \"r\") as f:\r\n            hexa_code = f.read()\r\n        f.close()\r\n        self.HexaCode.setText(hexa_code)\r\n\r\n        # Initialisation des noms des objets de la fenêtre\r\n        self.NameInit()\r\n        _translate = QtCore.QCoreApplication.translate\r\n        ConverterWindow.setWindowTitle(_translate(\"Converter\", \"Hexadecimal to Assembly Instructions Converter\"))\r\n\r\n        # Connexion de l'objet créé et de la fenêtre\r\n        QtCore.QMetaObject.connectSlotsByName(ConverterWindow)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ApplicationWindow.py b/ApplicationWindow.py
--- a/ApplicationWindow.py	
+++ b/ApplicationWindow.py	
@@ -1,3 +1,7 @@
+# Projet M1
+# Valentin Baudon et Hugo Merle
+# ISEN Nantes
+
 import csv
 import os
 import time
Index: SecondaryWindows.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nimport locale\r\nimport os\r\nimport sys\r\nfrom PyQt5 import QtWidgets, QtCore, Qt, QtGui\r\nfrom PyQt5.QtGui import QIcon, QTextCursor\r\nfrom PyQt5.QtWidgets import QDialog, QTextEdit, QVBoxLayout, QMainWindow, QLabel, QMenu, QAction, QButtonGroup\r\n\r\nfrom conversionHexToAssembly import *\r\n\r\n\r\n# Fonction pour récupérer le path des fichiers\r\ndef resource_path(relative_path):\r\n    try:\r\n        base_path = sys._MEIPASS2\r\n    except Exception:\r\n        base_path = os.path.abspath(\".\")\r\n\r\n    return os.path.join(base_path, relative_path)\r\n\r\n\r\n# Classe définissant la fenêtre \"Functionning\"\r\nclass Functionning(QDialog):\r\n    # constructeur de la classe \"Functionning\"\r\n    def __init__(self, langue):\r\n        # récupération des initialisations de la classe mère\r\n        super().__init__()\r\n\r\n        # paramètres généraux de la fenêtre\r\n        self.JSON_lang = json.load(open(resource_path(\"OtherFiles\\\\text_\" + langue + \".json\")))\r\n        self.setWindowTitle(self.JSON_lang[\"TitleFonctionnement\"])\r\n        self.resize(700, 520)\r\n        self.setFixedSize(700, 520)\r\n        icon = QIcon(resource_path(\"graphicResources\\\\TemporaryIcon.ico\"))\r\n        self.setWindowIcon(icon)\r\n\r\n        # initialisation des attributs de la classe\r\n        self.menu_Help = None\r\n        self.actionAbout = None\r\n        self.actionAboutFunctioning = None\r\n\r\n        # initialisation de l'objet texte\r\n        self.text_edit = QTextEdit(self)\r\n        self.text_edit.setReadOnly(True)\r\n        self.text_edit.setFontPointSize(11)\r\n        self.text_edit.setPlainText(self.JSON_lang[\"HowItWorks\"])\r\n        self.text_edit.setStyleSheet(\"background: transparent;\")\r\n\r\n        # initialisation du layout\r\n        layout = QVBoxLayout(self)\r\n        layout.addWidget(self.text_edit)\r\n\r\n\r\n# Classe définissant la fenêtre \"About\"\r\nclass About(QDialog):\r\n    # constructeur de la classe \"Functionning\"\r\n    def __init__(self, langue):\r\n        # récupération des initialisations de la classe mère\r\n        super().__init__()\r\n\r\n        # paramètres généraux de la fenêtre\r\n        self.JSON_lang = json.load(open(resource_path(\"OtherFiles\\\\text_\" + langue + \".json\")))\r\n        self.setWindowTitle(self.JSON_lang[\"actionAbout\"])\r\n        self.resize(650, 520)\r\n        self.setFixedSize(650, 520)\r\n        icon = QIcon(resource_path(\"graphicResources\\\\TemporaryIcon.ico\"))\r\n        self.setWindowIcon(icon)\r\n\r\n        # initialisation des attributs de la classe\r\n        self.menu_Help = None\r\n        self.actionAbout = None\r\n        self.actionAboutFunctioning = None\r\n\r\n        # initialisation et configuration de l'objet texte\r\n        self.text_edit = QTextEdit(self)\r\n        self.text_edit.setReadOnly(True)\r\n        self.text_edit.setFontPointSize(11)\r\n        self.text_edit.setPlainText(self.JSON_lang[\"about\"])\r\n        self.text_edit.setStyleSheet(\"background: transparent;\")\r\n        cursor = self.text_edit.textCursor()\r\n        cursor.movePosition(QTextCursor.End)\r\n        self.text_edit.setTextCursor(cursor)\r\n        self.text_edit.insertHtml('<img src=\"graphicResources\\\\isen_logo.png\">')\r\n        cursor.movePosition(QTextCursor.Start)\r\n        self.text_edit.setTextCursor(cursor)\r\n\r\n        # initialisation du layout\r\n        layout = QVBoxLayout(self)\r\n        layout.addWidget(self.text_edit)\r\n\r\n\r\n# Classe définissant la fenêtre \"Conversion simple\"\r\nclass SConversion(QDialog):\r\n    # constructeur de la classe \"SConversion\"\r\n    def __init__(self, langue):\r\n        # récupération des initialisations de la classe mère\r\n        super().__init__()\r\n\r\n        # initialisation des attributs de la classe par défaut\r\n        self.instruction = None\r\n        self.selected_OptionConversion = None\r\n        self.selected_typeInstruction = None\r\n        self.TypeInstruction_Group = None\r\n        self.ConvertedInstructionText = None\r\n        self.ResultTitle = None\r\n        self.ResultConversionLayout = None\r\n        self.ConvertButton = None\r\n        self.ConvertButtonLayout = None\r\n        self.RawInstructionText = None\r\n        self.InsertInstructionTittle = None\r\n        self.InsertInstructionLayout = None\r\n        self.IntegralOption = None\r\n        self.ClassiqueOption = None\r\n        self.CompactOption = None\r\n        self.ConversionOptionsTitle = None\r\n        self.ConversionOptionsLayout = None\r\n        self.BinaryInstruction = None\r\n        self.HexadecimalInstruction = None\r\n        self.InstructionTypeTitle = None\r\n        self.InstructionOptionsLayout = None\r\n        self.GlobalOptionsLayout = None\r\n        self.Title = None\r\n        self.TitleLayout = None\r\n        self.GlobalLayout = None\r\n        self.JSON_lang = json.load(open(resource_path(\"OtherFiles\\\\text_\" + langue + \".json\")))\r\n\r\n        # Initialisation de l'option de conversion sélectionnée par défaut\r\n        self.ConversionOption_Group = QtWidgets.QRadioButton()\r\n        self.ConversionOption_Group.setText(\"Compact\")\r\n\r\n    # Partie initialisation des textes et noms des éléments de la fenêtre\r\n    def NameInit(self):\r\n        _translate = QtCore.QCoreApplication.translate\r\n        self.Title.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"SC_Title\"]))\r\n        self.InstructionTypeTitle.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"SC_InstructionType\"]))\r\n        self.HexadecimalInstruction.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"SC_HexaInstruction\"]))\r\n        self.BinaryInstruction.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"SC_BinaryInstruction\"]))\r\n        self.ConversionOptionsTitle.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"SC_ConversionOptionTitle\"]))\r\n        self.CompactOption.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"CompactOption\"]))\r\n        self.ClassiqueOption.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"ClassiqueOption\"]))\r\n        self.IntegralOption.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"IntegralOption\"]))\r\n        self.InsertInstructionTittle.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"SC_InsertInstructionTitle\"]))\r\n        self.ConvertButton.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"convertButton\"]))\r\n        self.ResultTitle.setText(_translate(\"SimpleCWindow\", self.JSON_lang[\"SC_resultConversionTitle\"]))\r\n\r\n    # Fonction permettant de mettre à jour le bouton de type d'instruction sélectionnée\r\n    def store_TypeInstruction(self, button):\r\n        self.selected_typeInstruction = button\r\n\r\n    # Fonction permettant de mettre à jour le bouton d'option d'affichage sélectionnée\r\n    def store_OptionConversion(self, button):\r\n        self.selected_OptionConversion = button\r\n\r\n    # Fonction permettant de faire la traduction du fichier hexa et de mettre le résultat dans le fichier \"Assembly.txt\"\r\n    def translate(self):\r\n        self.instruction = self.RawInstructionText.toPlainText()\r\n\r\n        # type d'instruction : hexadécimale\r\n        if self.selected_typeInstruction.text()[:3] == \"Hex\":\r\n            with open(resource_path(\"ConversionFiles\\\\Hexa.txt\"), \"w\") as f:\r\n                f.write(self.instruction)\r\n            f.close()\r\n            writeBinaryInstructions(resource_path(\"ConversionFiles\\\\Hexa.txt\"), True)\r\n            describe_instructions(self.selected_OptionConversion.text(), True)\r\n\r\n        # type d'instruction : binaire\r\n        else:\r\n            with open(resource_path(\"ConversionFiles\\\\instructions_file.txt\"), \"w\") as f:\r\n                f.write(self.instruction)\r\n            f.close()\r\n            describe_instructions(self.selected_OptionConversion.text(), True)\r\n\r\n        with open(resource_path(\"ConversionFiles\\\\Assembly.txt\"), \"r\") as f:\r\n            assembly_code = f.read()\r\n        f.close()\r\n        self.ConvertedInstructionText.setText(assembly_code)\r\n\r\n    def setupUi(self):\r\n        # définition des polices d'écriture utilisées\r\n        font1 = QtGui.QFont()\r\n        font1.setPointSize(14)\r\n        font2 = QtGui.QFont()\r\n        font2.setPointSize(12)\r\n        font3 = QtGui.QFont()\r\n        font3.setPointSize(10)\r\n        font4 = QtGui.QFont()\r\n        font4.setPointSize(11)\r\n        font5 = QtGui.QFont()\r\n        font5.setPointSize(18)\r\n\r\n        # paramètres généraux de la fenêtre\r\n        self.setWindowTitle(self.JSON_lang[\"SC_Title\"])\r\n        self.resize(835, 544)\r\n        self.setFixedSize(835, 544)\r\n        icon = QIcon(resource_path(\"graphicResources\\\\TemporaryIcon.ico\"))\r\n        self.setWindowIcon(icon)\r\n\r\n        # Layout global\r\n        self.GlobalLayout = QVBoxLayout(self)\r\n        self.GlobalLayout.setObjectName(\"GlobalLayout\")\r\n\r\n        # layout du titre\r\n        self.TitleLayout = QtWidgets.QHBoxLayout()\r\n        self.TitleLayout.setObjectName(\"TitleLayout\")\r\n\r\n        # spacer à gauche du titre\r\n        LeftTitleSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.TitleLayout.addItem(LeftTitleSpacer)\r\n\r\n        # titre de la fenêtre\r\n        self.Title = QtWidgets.QLabel()\r\n        self.Title.setFont(font1)\r\n        self.Title.setObjectName(\"Title\")\r\n        self.TitleLayout.addWidget(self.Title)\r\n\r\n        # spacer à droite du titre\r\n        RightTitleSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.TitleLayout.addItem(RightTitleSpacer)\r\n        self.GlobalLayout.addLayout(self.TitleLayout)\r\n\r\n        # spacer sous le titre\r\n        TitleToOptionsSpacer = QtWidgets.QSpacerItem(13, 6, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\r\n        self.GlobalLayout.addItem(TitleToOptionsSpacer)\r\n\r\n        # layout global des options\r\n        self.GlobalOptionsLayout = QtWidgets.QHBoxLayout()\r\n        self.GlobalOptionsLayout.setObjectName(\"GlobalOptionsLayout\")\r\n\r\n        # spacer à gauche des options\r\n        LeftInstructionOptionsSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.GlobalOptionsLayout.addItem(LeftInstructionOptionsSpacer)\r\n\r\n        # layout des types d'instructions\r\n        self.InstructionOptionsLayout = QtWidgets.QVBoxLayout()\r\n        self.InstructionOptionsLayout.setObjectName(\"InstructionOptionsLayout\")\r\n\r\n        # titre des types d'instructions\r\n        self.InstructionTypeTitle = QtWidgets.QLabel()\r\n        self.InstructionTypeTitle.setFont(font2)\r\n        self.InstructionTypeTitle.setObjectName(\"InstructionTypeTittle\")\r\n        self.InstructionOptionsLayout.addWidget(self.InstructionTypeTitle)\r\n\r\n        # option type hexadécimal\r\n        self.TypeInstruction_Group = QButtonGroup()\r\n        self.HexadecimalInstruction = QtWidgets.QRadioButton()\r\n        self.HexadecimalInstruction.setFont(font3)\r\n        self.HexadecimalInstruction.setObjectName(\"HexadecimalInstruction\")\r\n        self.TypeInstruction_Group.addButton(self.HexadecimalInstruction)\r\n        self.InstructionOptionsLayout.addWidget(self.HexadecimalInstruction)\r\n\r\n        # option type binaire\r\n        self.BinaryInstruction = QtWidgets.QRadioButton()\r\n        self.BinaryInstruction.setFont(font3)\r\n        self.BinaryInstruction.setObjectName(\"BinaryInstruction\")\r\n        self.TypeInstruction_Group.addButton(self.BinaryInstruction)\r\n        self.InstructionOptionsLayout.addWidget(self.BinaryInstruction)\r\n        self.GlobalOptionsLayout.addLayout(self.InstructionOptionsLayout)\r\n\r\n        # spacer entre les 2 parties des options\r\n        BetweenOptionsSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.GlobalOptionsLayout.addItem(BetweenOptionsSpacer)\r\n\r\n        # layout des options de conversion\r\n        self.ConversionOptionsLayout = QtWidgets.QVBoxLayout()\r\n        self.ConversionOptionsLayout.setObjectName(\"ConversionOptionsLayout\")\r\n\r\n        # titre des options de conversion\r\n        self.ConversionOptionsTitle = QtWidgets.QLabel()\r\n        self.ConversionOptionsTitle.setFont(font2)\r\n        self.ConversionOptionsTitle.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.ConversionOptionsTitle.setObjectName(\"ConversionOptionsTittle\")\r\n        self.ConversionOptionsLayout.addWidget(self.ConversionOptionsTitle)\r\n\r\n        # option conversion \"Compact\"\r\n        self.ConversionOption_Group = QButtonGroup()\r\n        self.CompactOption = QtWidgets.QRadioButton()\r\n        self.CompactOption.setFont(font3)\r\n        self.CompactOption.setObjectName(\"CompactOption\")\r\n        self.ConversionOption_Group.addButton(self.CompactOption)\r\n        self.ConversionOptionsLayout.addWidget(self.CompactOption)\r\n\r\n        # option conversion \"Classique\"\r\n        self.ClassiqueOption = QtWidgets.QRadioButton()\r\n        self.ClassiqueOption.setFont(font3)\r\n        self.ClassiqueOption.setObjectName(\"ClassiqueOption\")\r\n        self.ConversionOption_Group.addButton(self.ClassiqueOption)\r\n        self.ConversionOptionsLayout.addWidget(self.ClassiqueOption)\r\n\r\n        # option conversion \"Intégrale\"\r\n        self.IntegralOption = QtWidgets.QRadioButton()\r\n        self.IntegralOption.setFont(font3)\r\n        self.IntegralOption.setObjectName(\"IntegralOption\")\r\n        self.ConversionOption_Group.addButton(self.IntegralOption)\r\n        self.ConversionOptionsLayout.addWidget(self.IntegralOption)\r\n        self.GlobalOptionsLayout.addLayout(self.ConversionOptionsLayout)\r\n\r\n        # spacer droite des options\r\n        RightOptionsSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.GlobalOptionsLayout.addItem(RightOptionsSpacer)\r\n        self.GlobalLayout.addLayout(self.GlobalOptionsLayout)\r\n\r\n        # spacer sous options\r\n        OptionsToInsertInstructionsSpacer = QtWidgets.QSpacerItem(17, 6, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\r\n        self.GlobalLayout.addItem(OptionsToInsertInstructionsSpacer)\r\n\r\n        # layout insertion instruction\r\n        self.InsertInstructionLayout = QtWidgets.QHBoxLayout()\r\n        self.InsertInstructionLayout.setObjectName(\"InsertInstructionLayout\")\r\n\r\n        # spacer gauche titre insertion instruction\r\n        LeftInsertInstructionSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.InsertInstructionLayout.addItem(LeftInsertInstructionSpacer)\r\n\r\n        # titre insertion instruction\r\n        self.InsertInstructionTittle = QtWidgets.QLabel()\r\n        self.InsertInstructionTittle.setFont(font4)\r\n        self.InsertInstructionTittle.setObjectName(\"InsertInstructionTittle\")\r\n        self.InsertInstructionLayout.addWidget(self.InsertInstructionTittle)\r\n\r\n        # spacer droite titre insertion instruction\r\n        RightInsertInstructionSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.InsertInstructionLayout.addItem(RightInsertInstructionSpacer)\r\n        self.GlobalLayout.addLayout(self.InsertInstructionLayout)\r\n\r\n        # zone de texte insertion instruction\r\n        self.RawInstructionText = QtWidgets.QTextEdit()\r\n        self.RawInstructionText.setMaximumSize(QtCore.QSize(16777215, 50))\r\n        self.RawInstructionText.setFont(font2)\r\n        self.RawInstructionText.setObjectName(\"RawInstructionText\")\r\n        self.GlobalLayout.addWidget(self.RawInstructionText)\r\n\r\n        # spacer sous zone de texte insertion instruction\r\n        RawInstructionToConvertButtonSpacer = QtWidgets.QSpacerItem(17, 6, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\r\n        self.GlobalLayout.addItem(RawInstructionToConvertButtonSpacer)\r\n\r\n        # layout bouton conversion\r\n        self.ConvertButtonLayout = QtWidgets.QHBoxLayout()\r\n        self.ConvertButtonLayout.setObjectName(\"ConvertButtonLayout\")\r\n\r\n        # spacer gauche bouton conversion\r\n        LeftConvertButtonSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.ConvertButtonLayout.addItem(LeftConvertButtonSpacer)\r\n\r\n        # bouton conversion\r\n        self.ConvertButton = QtWidgets.QPushButton()\r\n        self.ConvertButton.setFont(font5)\r\n        self.ConvertButton.setObjectName(\"ConvertButton\")\r\n        self.ConvertButtonLayout.addWidget(self.ConvertButton)\r\n\r\n        # spacer droite bouton conversion\r\n        RightConvertButtonSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.ConvertButtonLayout.addItem(RightConvertButtonSpacer)\r\n        self.GlobalLayout.addLayout(self.ConvertButtonLayout)\r\n\r\n        # spacer sous bouton conversion\r\n        ConvertButtonToResultTitleSpacer = QtWidgets.QSpacerItem(17, 6, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\r\n        self.GlobalLayout.addItem(ConvertButtonToResultTitleSpacer)\r\n\r\n        # layout résultat conversion\r\n        self.ResultConversionLayout = QtWidgets.QHBoxLayout()\r\n        self.ResultConversionLayout.setObjectName(\"ResultConversionLayout\")\r\n\r\n        # spacer gauche titre résultat conversion\r\n        LeftResultTitleSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.ResultConversionLayout.addItem(LeftResultTitleSpacer)\r\n\r\n        # titre résultat conversion\r\n        self.ResultTitle = QtWidgets.QLabel()\r\n        self.ResultTitle.setFont(font4)\r\n        self.ResultTitle.setObjectName(\"ResultTittle\")\r\n        self.ResultConversionLayout.addWidget(self.ResultTitle)\r\n\r\n        # spacer droite titre résultat conversion\r\n        RightResultTitleSpacer = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\r\n        self.ResultConversionLayout.addItem(RightResultTitleSpacer)\r\n        self.GlobalLayout.addLayout(self.ResultConversionLayout)\r\n\r\n        # zone de texte résultat conversion\r\n        self.ConvertedInstructionText = QtWidgets.QTextEdit()\r\n        self.ConvertedInstructionText.setMaximumSize(QtCore.QSize(16777215, 60))\r\n        self.ConvertedInstructionText.setFont(font2)\r\n        self.ConvertedInstructionText.setObjectName(\"ConvertedInstructionText\")\r\n        self.ConvertedInstructionText.setReadOnly(True)\r\n        self.GlobalLayout.addWidget(self.ConvertedInstructionText)\r\n\r\n        # spacer sous zone de texte résultat conversion\r\n        ConvertedInstructionToBottomSpacer = QtWidgets.QSpacerItem(18, 6, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\r\n        self.GlobalLayout.addItem(ConvertedInstructionToBottomSpacer)\r\n\r\n        # Partie connection aux actions quand clic de l'utilisateur\r\n        self.TypeInstruction_Group.buttonClicked.connect(self.store_TypeInstruction)\r\n        self.ConversionOption_Group.buttonClicked.connect(self.store_OptionConversion)\r\n        self.ConvertButton.clicked.connect(self.translate)\r\n\r\n        # initialisation des noms des objets et connexion aux slots\r\n        self.NameInit()\r\n        QtCore.QMetaObject.connectSlotsByName(self)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/SecondaryWindows.py b/SecondaryWindows.py
--- a/SecondaryWindows.py	
+++ b/SecondaryWindows.py	
@@ -1,3 +1,7 @@
+# Projet M1
+# Valentin Baudon et Hugo Merle
+# ISEN Nantes
+
 import json
 import locale
 import os
Index: HexaToAssemblyConverterApplication.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ApplicationWindow import *\r\n\r\n\r\n# Fonction pour récupérer le path des fichiers\r\ndef resource_path(relative_path):\r\n    try:\r\n        base_path = sys._MEIPASS2\r\n    except Exception:\r\n        base_path = os.path.abspath(\".\")\r\n    return os.path.join(base_path, relative_path)\r\n\r\n\r\n# Permet de récupérer le logo pour la génération de l'exécutable\r\nLogo = resource_path(\"graphicResources/TemporaryIcon.ico\")\r\n\r\n# Initialisation des composantes fenêtres de l'application\r\napp = QtWidgets.QApplication(sys.argv)\r\nHexaToAssemblyConverter = QtWidgets.QMainWindow()\r\nwindow = MainWindow()\r\n\r\n# Affichage et lien des fenêtres créés aux objets et valeurs créés dans le fichier \"ApplicationWindow.py\"\r\nwindow.setupUi(HexaToAssemblyConverter)\r\nHexaToAssemblyConverter.show()\r\nsys.exit(app.exec_())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/HexaToAssemblyConverterApplication.py b/HexaToAssemblyConverterApplication.py
--- a/HexaToAssemblyConverterApplication.py	
+++ b/HexaToAssemblyConverterApplication.py	
@@ -1,3 +1,7 @@
+# Projet M1
+# Valentin Baudon et Hugo Merle
+# ISEN Nantes
+
 from ApplicationWindow import *
 
 
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n# Projet M1\r\n### Traducteur de fichier hexa bruts provenant de microcontrôleurs basés sur une architecture ARM vers leur code assembleur\r\n\r\nCette application est un moyen de convertir des fichiers hexadécimaux en leur code assembleur.\r\n\r\nLe fonctionnement de l'application est simple :\r\n\r\n    1) Cliquez sur le bouton 'Download Hex File' pour télécharger le fichier héxadecimal que vous souhaitez traduire. Le contenu de votre fichier original devrait s'afficher dans le carré de texte comportant l'en-tete 'Hexadécimal'\r\n    2) Selectionnez l'option d'affichage qui vous convient\r\n    Plusieurs options d'affichage sont disponibles:\r\n        - Compact : instruction et valeurs\r\n        - Classique : instruction détaillée et valeurs\r\n        - Intégral : valeur binaire correspondante à l'instruction, instruction détaillée et valeurs\r\n\r\n    3) Cliquez sur le bouton 'Convertir'. Le contenu de votre fichier original traduit en assembleur devrait s'afficher dans le carré de texte comportant l'en-tete 'Assembleur'\r\n\r\n    Si l'affichage obtenu ne vous convient pas, sélectionnez votre nouvelle option d'affichage et cliquez de nouveau sur le bouton 'Convertir'. Le nouveau contenu obtenu devrait remplacer l'ancien résultat.\r\n\r\n    4) Pour télécharger ce visuel ou vous voulez sur votre ordinateur, cliquez sur le bouton 'Download Assembly File'\r\n    \r\n    Exemple d'affichage selon les options selectionnées\r\n        - Compact: 0x08000003 : LSR (immediate) : R7, R3, #28\r\n        - Classic: 0x08000003 : Logical Shift Right (Immediate) : R7, R3, #28\r\n        - Integral: 0x08000003 : 0000111100011111 : Logical Shift Right (Immediate) : R7, R3, #28\r\n\r\nInstallation via fichier setup :\r\n\r\n    1) Une fois que le fichier \"HexToAssembly_WINDOWS_2.0_setup.exe\" est installé sur votre ordinateur, lancez l'installation.\r\n\r\n    2) A la dernière étape de l'installation, décochez l'ouverture automatique du logiciel et finissez l'installation.\r\n\r\n    3) Faites clic droit -> \"Exécuter en tant qu'administrateur\" pour que le logiciel fonctionne correctement.\r\n\r\n    4) Le logiciel est correctement installé et fonctionnel sur votre ordinateur\r\n\r\nProjet réalisé par Valentin BAUDON et Hugo MERLE, sous la direction de M. Jean-Jacques MENEU\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	
+++ b/README.md	
@@ -4,26 +4,6 @@
 
 Cette application est un moyen de convertir des fichiers hexadécimaux en leur code assembleur.
 
-Le fonctionnement de l'application est simple :
-
-    1) Cliquez sur le bouton 'Download Hex File' pour télécharger le fichier héxadecimal que vous souhaitez traduire. Le contenu de votre fichier original devrait s'afficher dans le carré de texte comportant l'en-tete 'Hexadécimal'
-    2) Selectionnez l'option d'affichage qui vous convient
-    Plusieurs options d'affichage sont disponibles:
-        - Compact : instruction et valeurs
-        - Classique : instruction détaillée et valeurs
-        - Intégral : valeur binaire correspondante à l'instruction, instruction détaillée et valeurs
-
-    3) Cliquez sur le bouton 'Convertir'. Le contenu de votre fichier original traduit en assembleur devrait s'afficher dans le carré de texte comportant l'en-tete 'Assembleur'
-
-    Si l'affichage obtenu ne vous convient pas, sélectionnez votre nouvelle option d'affichage et cliquez de nouveau sur le bouton 'Convertir'. Le nouveau contenu obtenu devrait remplacer l'ancien résultat.
-
-    4) Pour télécharger ce visuel ou vous voulez sur votre ordinateur, cliquez sur le bouton 'Download Assembly File'
-    
-    Exemple d'affichage selon les options selectionnées
-        - Compact: 0x08000003 : LSR (immediate) : R7, R3, #28
-        - Classic: 0x08000003 : Logical Shift Right (Immediate) : R7, R3, #28
-        - Integral: 0x08000003 : 0000111100011111 : Logical Shift Right (Immediate) : R7, R3, #28
-
 Installation via fichier setup :
 
     1) Une fois que le fichier "HexToAssembly_WINDOWS_2.0_setup.exe" est installé sur votre ordinateur, lancez l'installation.
